<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  
  <script>
  // Redirección automática a la versión móvil (se puede forzar escritorio con ?desktop=1)
  (function(){
    try{
      const params = new URLSearchParams(location.search);
      if (params.get("desktop") === "1") return;

      const ua = navigator.userAgent || "";
      const isUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
      const isCoarse = (window.matchMedia && window.matchMedia("(pointer:coarse)").matches) || false;
      const smallScreen = Math.min(screen.width || 9999, screen.height || 9999) <= 900;

      const isMobile = isUA || (isCoarse && smallScreen);
      const onMobilePage = /mobile\.html$/i.test(location.pathname);

      if (isMobile && !onMobilePage){
        const target = "mobile.html" + location.search + location.hash;
        location.replace(target);
      }
    }catch(e){}
  })();
  </script>
<title>Entendiendo la economía de España</title>

  <style>

    :root{
      --uiScale: 1.35;

      --bg:#252525;
      --primary:#FEF702;
      --text:#B0B0B0;
      --grid:#4A4A4A;
      --stroke:#3a3a3a;

      --fontTitle: "Futura","Trebuchet MS",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      --fontText:  Arial,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;

      --radius:14px;
      --shadow: 0 10px 30px rgba(0,0,0,.25);
    }

    *{box-sizing:border-box}
    html, body{ height:100%; }

    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:var(--fontText);
      font-size: calc(14px * var(--uiScale));

      display:flex;
      flex-direction:column;
      height:100vh;
      min-height:100vh;
      overflow:hidden;
    }

    header{
      padding:18px 18px 8px 18px;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
      flex: 0 0 auto;
    }

    .h-title{ line-height:1.05; }
    .h-title h1{
      margin:0;
      font-family:var(--fontTitle);
      color:var(--primary);
      font-size: calc(22px * var(--uiScale));
      letter-spacing:.3px;
    }

    .tabs{
      margin-top:10px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    main{
      flex: 1 1 auto;
      min-height:0;
      display:grid;
      grid-template-columns: 340px 1fr;
      gap:12px;
      padding:12px 12px 18px 12px;
      overflow:hidden;
    }

    .view{ display:none !important; }
    .view.active{ display:grid !important; }

    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      min-height:0;
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    .ph{
      padding:12px 12px 10px 12px;
      border-bottom:1px solid var(--stroke);
      background:rgba(255,255,255,.02);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      min-height:44px;
      flex: 0 0 auto;
    }
    .ttl{
      font-family:var(--fontTitle);
      color:var(--primary);
      font-size: calc(13px * var(--uiScale));
      letter-spacing:.35px;
      text-transform:uppercase;
      white-space:nowrap;
      flex:0 0 auto;
    }
    .sub{
      font-size: calc(12px * var(--uiScale));
      opacity:.8;
      white-space:nowrap;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
      flex:1 1 auto;
    }

    .pc{
      padding:12px;
      overflow:auto;
      min-height:0;
      flex: 1 1 auto;
    }

    /* Botones */
    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color: rgba(255,255,255,.9);
      padding: 9px 12px;
      border-radius: 10px;
      font-size: calc(12px * var(--uiScale));
      cursor:pointer;
      user-select:none;
      transition: transform .04s ease, border-color .12s ease, background .12s ease;
      line-height:1;
      white-space:nowrap;
      text-decoration: none !important;
    }
    .btn:hover{ border-color: rgba(254,247,2,.35); background: rgba(255,255,255,.06); }
    .btn:active{ transform: translateY(1px); }
    .btn.on{
      background: rgba(254,247,2,.9);
      border-color: rgba(254,247,2,.95);
      color: rgba(0,0,0,.92);
      font-weight: 700;
    }
    .btn.tab{
      border-radius: 999px;
      padding: 10px 14px;
    }

    /* Botón Inicio (esquina superior derecha) */
    .homeTopRight{
      position: fixed;
      top: 18px;
      right: 18px;
      z-index: 2000;
    }

    @media (max-width: 900px){
      .homeTopRight{
        top: 10px;
        right: 10px;
      }
    }

    /* Leyenda/lista */
    .legend{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .item{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 10px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.02);
      border-radius:12px;
      box-shadow: 0 6px 18px rgba(0,0,0,.10);
      cursor:pointer;
      user-select:none;
      min-width:0;
    }
    .item:hover{ border-color: rgba(254,247,2,.25); }
    .sw{ width:12px; height:12px; border-radius:3px; flex:0 0 auto; }
    .nm{
      flex:1 1 auto;
      font-size: calc(12px * var(--uiScale));
      line-height:1.15;
      min-width:0;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .badge{
      font-size: calc(10px * var(--uiScale));
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      opacity:.85;
      flex:0 0 auto;
    }
    .muted{ opacity:.35; }

    /* GRÁFICO */
    .chartPc{
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:hidden;
      min-height:0;
    }

    .svgWrap{
      position:relative;
      flex: 1 1 0;
      min-height:0;
      border-radius: 12px;
      overflow: hidden;
      background: rgba(0,0,0,.08);
      border: 1px solid rgba(255,255,255,.06);
    }

    svg.chartSvg{
      width:100%;
      height:100%;
      display:block;
    }

    .tooltip{
      position:absolute;
      z-index:3;
      min-width: 240px;
      max-width: 420px;
      max-height: 420px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.82);
      backdrop-filter: blur(6px);
      border-radius: 12px;
      padding: 10px 10px;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      pointer-events:none;
      font-size: calc(12px * var(--uiScale));
      line-height: 1.25;
    }
    .ttYear{
      font-family: var(--fontTitle);
      color: var(--primary);
      letter-spacing:.2px;
      margin-bottom:6px;
      font-size: calc(13px * var(--uiScale));
    }
    .ttRow{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 3px 0;
      border-bottom: 1px dashed rgba(255,255,255,.08);
    }
    .ttRow:last-child{ border-bottom:none; }
    .ttSw{
      width:10px; height:10px; border-radius:3px; flex:0 0 auto;
    }
    .ttName{
      flex: 1 1 auto;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: rgba(255,255,255,.90);
      min-width:0;
    }
    .ttVal{
      flex:0 0 auto;
      color: rgba(255,255,255,.95);
      font-variant-numeric: tabular-nums;
      white-space:nowrap;
    }

    .chartControls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      flex: 0 0 auto;
    }

    .footerSingle{
      flex: 0 0 auto;
      font-size: calc(12px * var(--uiScale));
      opacity:.85;
      padding-bottom: 2px;

      display:flex;
      flex-direction:column;     /* <-- clave: apila en vertical */
      align-items:flex-start;    /* <-- clave: todo a la izquierda */
      justify-content:flex-start;
      gap:4px;                   /* separación entre Fuente y Presidentes */
    }

    .footerPres{
      margin-left:0;             /* <-- quita el empuje a la derecha */
      text-align:left;           /* <-- izquierda */
      white-space:normal;        /* <-- permite salto de línea si hace falta */
      opacity:.85;
    }
    @media (max-width: 900px){
      .footerPres{ white-space:normal; }
    }

    .errorBox{
      position:absolute;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:18px;
      color: rgba(255,255,255,.90);
      font-size: calc(13px * var(--uiScale));
      background: rgba(0,0,0,.35);
      z-index:2;
    }

    @media (max-width: 900px){
      body{ overflow:auto; }
      main{
        overflow:visible;
        grid-template-columns: 1fr;
      }
      .svgWrap{ height: 520px; min-height: 520px; }
      .pc{ overflow:visible; }
    }
  
    /* ===================== Bloque presidencias (vista: Gasto vs beneficio) ===================== */
    .presStats{
      margin-top: 10px;
      padding: 12px 12px 10px 12px;
      border: 1px solid rgba(255,255,255,.06);
      border-radius: 12px;
      background: rgba(0,0,0,.10);
      overflow:hidden;
    }
    .presStats .psTop{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding-bottom:10px;
      margin-bottom:10px;
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .presStats .psItem{
      display:flex;
      align-items:center;
      gap:10px;
      font-size: calc(13px * var(--uiScale));
      line-height:1.1;
      opacity:.95;
    }
    .presStats .psSw{
      width:10px; height:10px;
      border-radius:3px;
      flex:0 0 auto;
      background:#fff;
    }
    .presStats .psLabel{
      flex:1 1 auto;
      min-width:0;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .presStats .psVal{
      flex:0 0 auto;
      opacity:.95;
      font-variant-numeric: tabular-nums;
    }
    .presStats .psGrid{
      display:grid;
      grid-template-columns: 240px 1fr;
      gap: 12px 18px;
      align-items:start;
    }
    .presStats .psLeft{
      font-size: calc(13px * var(--uiScale));
      line-height:1.15;
      opacity:.9;
      white-space:pre-line;
    }
    .presStats .psLeft .yrs{ opacity:.75; }
    .presStats .psRight{
      display:flex;
      flex-direction:column;
      gap:4px;
      font-size: calc(13px * var(--uiScale));
      font-variant-numeric: tabular-nums;
    }
    .presStats .psLine{
      display:flex;
      gap:6px;
      align-items:baseline;
      line-height:1.05;
    }
    .presStats .psLine .k{ opacity:.85; }
    .presStats .psLine .v{ opacity:.98; }


    /* --- Formato mandatos (GB): título + líneas en vertical (mejor legibilidad) --- */
    .presStats .psBlocks{
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    .presStats .psMandate{
      padding-top:10px;
      border-top:1px solid rgba(255,255,255,.06);
    }
    .presStats .psMandate:first-child{
      padding-top:0;
      border-top:none;
    }
    .presStats .psMandateTitle{
      font-size: calc(14px * var(--uiScale));
      line-height:1.15;
      opacity:.92;
      white-space:pre-line;
    }
    .presStats .psMandateTitle .yrs{
      opacity:.75;
      margin-left: 0;
    }
    .presStats .psMandateLine{
      margin-top:6px;
      display:flex;
      flex-direction:column;
      gap:2px;
      line-height:1.05;
    }
    .presStats .psMandateLine .k{
      opacity:.85;
    }
    .presStats .psMandateLine .v{
      opacity:.98;
      font-variant-numeric: tabular-nums;
    }

    /* Asegurar que los mandatos se lean en una sola columna (evita el “bloque a la derecha”) */
    .presStats .psMandateLine{ align-items:flex-start; }
    .presStats .psMandateLine .k,
    .presStats .psMandateLine .v{ width:100%; text-align:left; }



    /* ===== Ajustes de layout para evitar “apelmazado” en Vistas 2 y 3 ===== */
    #viewGB .pc.chartPc,
    #viewPA .pc.chartPc,
    #viewPGE .pc.chartPc{
      overflow-y: auto;
    }
    #viewGB .svgWrap,
    #viewPA .svgWrap,
    #viewPGE .svgWrap{
      flex: 1 1 auto;
      min-height: 520px;
    }
    #viewGB .presStats{ flex: 0 0 auto; }

    #viewPGE #btnExplainPGE,
    #viewGB #btnExplainGB,
    #viewPA #btnExplainPA{
      margin-left: auto;
    }

        /* Scroll en el panel izquierdo (GB/PA) como en PGE */
    #viewGB > section.panel:first-child .pc,
    #viewPA > section.panel:first-child .pc{
      overflow-y:auto;
      padding-right: 4px;
    }
.explainBox{
      margin-top: 12px;
      padding: 12px 14px;
      border: 1px solid var(--stroke);
      border-radius: 12px;
      background: rgba(255,255,255,.02);
    }
    .explainTitle{
      font-family: var(--fontTitle);
      color: var(--primary);
      font-size: calc(14px * var(--uiScale));
      margin-bottom: 6px;
      letter-spacing: .2px;
    }
    .explainText{
      font-size: calc(12px * var(--uiScale));
      line-height: 1.45;
      color: rgba(176,176,176,.95);
    }
    .explainText ul{ margin: 6px 0 0 18px; }
    .explainText ol{ margin: 6px 0 0 18px; }
    .explainText code{
      font-size: calc(11px * var(--uiScale));
      color: rgba(255,255,255,.9);
    }


    /* --- Explicación desplegable (GB/PA) --- */
    .explainCollapsible{
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      transform: translateY(-4px);
      transition: max-height .28s ease, opacity .22s ease, transform .22s ease, margin-top .22s ease, padding .22s ease, border-color .22s ease;
      padding-top: 0;
      padding-bottom: 0;
      margin-top: 0;
      border-color: rgba(255,255,255,0);
    }
    .explainCollapsible.open{
      max-height: 1200px;
      opacity: 1;
      transform: translateY(0);
      padding-top: 12px;
      padding-bottom: 12px;
      margin-top: 12px;
      border-color: var(--stroke);
    }

    /* Población (tabla) - Vista GB */
    .popBox{
      margin-top: 12px;
      padding: 12px 14px;
      border: 1px solid var(--stroke);
      border-radius: 12px;
      background: rgba(255,255,255,.02);
    }
    .popTitle{
      font-family: var(--fontTitle);
      color: var(--primary);
      font-size: calc(14px * var(--uiScale));
      margin-bottom: 8px;
    }
    .popTableScroll{
      max-height: 260px;
      overflow: auto;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.08);
    }
    table.popTable{
      width: 100%;
      border-collapse: collapse;
      font-size: calc(12px * var(--uiScale));
    }
    table.popTable thead th{
      position: sticky;
      top: 0;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(4px);
      text-align: left;
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      color: rgba(255,255,255,.92);
      z-index: 1;
    }
    table.popTable tbody td{
      padding: 7px 10px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      color: rgba(255,255,255,.85);
      white-space: nowrap;
    }
    table.popTable tbody tr:hover td{
      background: rgba(255,255,255,.04);
      color: rgba(255,255,255,.95);
    }


    /* Tabla de correspondencias (PGE) */
    .mapTableScroll{
      margin-top: 10px;
      max-height: 420px;
      overflow: auto;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.08);
    }
    table.mapTable{
      width: 100%;
      border-collapse: collapse;
      font-size: calc(12px * var(--uiScale));
    }
    table.mapTable thead th{
      position: sticky;
      top: 0;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(4px);
      text-align: left;
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      color: rgba(255,255,255,.92);
      z-index: 1;
    }
    table.mapTable tbody td{
      padding: 7px 10px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      color: rgba(255,255,255,.85);
      vertical-align: top;
    }
    table.mapTable tbody tr:hover td{
      background: rgba(255,255,255,.04);
      color: rgba(255,255,255,.95);
    }
    .mapOldItem{
      display:block;
      white-space: nowrap;
    }

    /* ===== Vistas GB/PA: explicación debajo de Series + Gráfico (se ve con scroll) ===== */
    #viewGB.view.active,
    #viewPA.view.active,
    #viewPGE.view.active{
      display:flex !important;
      flex-direction:column;
      gap:12px;
      overflow-y:auto;
      overflow-x:hidden;
    }

    /* FIX: en layout flex, el panel de "Explicación" se estaba encogiendo a 0px
       porque .topGrid ocupa height:100% y el segundo item (section.panel) tenía flex-shrink:1.
       Forzamos a que NO se encoja, para que quede debajo y se pueda ver haciendo scroll. */
    #viewGB.view.active > section.panel,
    #viewPA.view.active > section.panel,
    #viewPGE.view.active > section.panel{
      flex: 0 0 auto;
    }
    #viewGB .topGrid,
    #viewPA .topGrid,
    #viewPGE .topGrid{
      display:grid;
      grid-template-columns: 340px 1fr;
      grid-template-rows: 1fr;
      gap:12px;
      /* ocupa toda la altura visible para que la explicación quede fuera de pantalla */
      height:100%;
      min-height:100%;
      flex: 0 0 auto;
    }
    #viewGB .topGrid > .panel,
    #viewPA .topGrid > .panel,
    #viewPGE .topGrid > .panel{
      height:100%;
    }
    /* sin scroll interno del panel de gráfico (el scroll es del main) */
    #viewGB .pc.chartPc,
    #viewPA .pc.chartPc,
    #viewPGE .pc.chartPc{
      overflow:hidden;
    }
    #viewGB .svgWrap,
    #viewPA .svgWrap,
    #viewPGE .svgWrap{
      flex: 1 1 auto;
      min-height: 520px;
    }

    @media (max-width: 900px){
      #viewGB.view.active,
    #viewPA.view.active,
    #viewPGE.view.active{
        overflow:visible;
      }
      #viewGB .topGrid,
    #viewPA .topGrid,
    #viewPGE .topGrid{
        grid-template-columns: 1fr;
        min-height:0;
      }
    }

    a.btn.homeTopRight{
      border:1px solid rgba(255,255,255,.16) !important;
      background:rgba(0,0,0,.18) !important;
      color:var(--primary) !important;

      padding:10px 14px !important;
      border-radius:999px !important;
      box-shadow: var(--shadow) !important;

      text-decoration:none !important;
      text-decoration-line:none !important;
      border-bottom:0 !important;

      display:inline-flex !important;
      align-items:center !important;
      justify-content:center !important;
      gap:8px !important;

      font-family:var(--fontTitle) !important;
      letter-spacing:.2px !important;
      line-height:1 !important;
    }

    a.btn.homeTopRight:hover{
      border-color: rgba(254,247,2,.35) !important;
      background: linear-gradient(180deg, rgba(254,247,2,.07), rgba(0,0,0,.18)) !important;
    }

    a.btn.homeTopRight:visited,
    a.btn.homeTopRight:active,
    a.btn.homeTopRight:focus{
      color:var(--primary) !important;
      text-decoration:none !important;
      outline:none !important;
    }
  </style>
</head>

<body>

  <a class="btn homeTopRight" href="../index.html" title="Volver al inicio">← Volver al inicio</a>

  <header>
    <div class="h-title">
      <h1>entendiendo la economía de España</h1>
      <div class="tabs" role="tablist" aria-label="Secciones">
        <button class="btn tab on" data-view="pge" role="tab" aria-selected="true">Presupuestos generales del Estado</button>
        <button class="btn tab" data-view="gb" role="tab" aria-selected="false">Gasto vs beneficio</button>
        <button class="btn tab" data-view="pa" role="tab" aria-selected="false">Presión fiscal</button>
</div>
    </div>
  </header>

    <!-- ===================== VISTA 1: PGE ===================== -->
  <main id="viewPGE" class="view active">
    <div class="topGrid">
      <section class="panel">
        <div class="ph">
          <div class="ttl">Políticas</div>
          <div class="sub">
            <button class="btn" id="btnPre2004" title="Alternar entre vista compactada y vista completa">Vista completa</button>
          </div>
        </div>
        <div class="pc">
          <div class="legend" id="legend"></div>
        </div>
      </section>

      <section class="panel">
        <div class="ph">
          <div class="ttl">Gráfico</div>
          <div class="sub"></div>
        </div>

        <div class="pc chartPc">
          <div class="svgWrap" id="svgWrap">
            <svg id="chartSvg" class="chartSvg" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Gráfico de porcentaje del presupuesto por política y año"></svg>
            <div class="tooltip" id="tooltip" style="display:none;"></div>
            <div class="errorBox" id="errorBox" style="display:none;"></div>
          </div>

          <div class="chartControls">
            <button class="btn" id="btnScale">Escala: Exponencial</button>
            <button class="btn" id="btnCrosshair">Línea vertical: OFF</button>
            <button class="btn" id="btnHoverFocus">Resaltar al pasar: OFF</button>
            <button class="btn on" id="btnPolBandsPGE" title="Mostrar/ocultar colores de presidencias">Políticos: ON</button>
            <button class="btn" id="btnExplainPGE" title="Ir a la explicación">Explicación</button>
          </div>

          <div class="footerSingle">
            <span class="footerSource">Fuente: <span style="color:#fff">BOE</span> · <span style="opacity:.9;">N.Geolitics</span></span>
            <span class="footerPres">Felipe González (1986–1996) · José María Aznar (1996–2004) · José Luis Rodríguez Zapatero (2004–2011) · Mariano Rajoy (2011–2018) · Pedro Sánchez (2018–2023)</span>
          </div>
        </div>
      </section>
    </div>

    <section class="panel">
      <div class="ph">
        <div class="ttl">Explicación</div>
        <div class="sub"></div>
      </div>
      <div class="pc">
        <div class="explainBox" id="pgeExplain">
          <div class="explainTitle">Cómo se agregan las políticas antiguas a las modernas</div>
          <div class="explainText">
            <div>
              El BOE utiliza distintos esquemas de clasificación según el periodo. Para tener una serie consistente, aquí se muestran
              <b>solo</b> las <b>políticas modernas</b> (<code>id_politica_moderno</code>), y para cada una se suman las partidas históricas
              indicadas en <code>pge_politicas.csv</code>.
            </div>
            <div style="margin-top:8px;">
              La tabla siguiente indica la correspondencia usada (columna <code>politicas_antiguas_encontradas</code> → serie moderna).
            </div>
          </div>

          <div class="mapTableScroll" aria-label="Tabla de correspondencias PGE: políticas modernas y políticas antiguas agregadas">
            <table class="mapTable">
              <thead>
                <tr>
                  <th>Política moderna</th>
                  <th>Políticas antiguas agregadas</th>
                </tr>
              </thead>
              <tbody id="pgeMapBody"></tbody>
            </table>
          </div>

          <div class="explainText" id="pgeUnmappedNote" style="margin-top:10px; opacity:.95;"></div>
        </div>
      </div>
    </section>
  </main>


  <!-- ===================== VISTA 2: Gasto vs beneficio ===================== -->
  <main id="viewGB" class="view">
    <div class="topGrid">
      <section class="panel">
        <div class="ph">
          <div class="ttl">Series</div>
          <div class="sub">1986–2023</div>
        </div>
        <div class="pc">
          <div class="legend" id="legendGB"></div>
          <div class="presStats" id="gbPresStats" aria-label="Resumen por presidencias"></div>
        </div>
      </section>

      <section class="panel">
        <div class="ph">
          <div class="ttl">Gráfico</div>
          <div class="sub"></div>
        </div>

        <div class="pc chartPc">
          <div class="svgWrap" id="svgWrapGB">
            <svg id="chartSvgGB" class="chartSvg" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Gráfico de PIB y gasto público en euros constantes 1986"></svg>
            <div class="tooltip" id="tooltipGB" style="display:none;"></div>
            <div class="errorBox" id="errorBoxGB" style="display:none;"></div>
          </div>

          <div class="chartControls">
            <button class="btn" id="btnCrosshairGB">Línea vertical: OFF</button>
            <button class="btn on" id="btnPolBandsGB" title="Mostrar/ocultar colores de presidencias">Políticos: ON</button>
            <button class="btn" id="btnPopGB" title="Mostrar/ocultar flechas de variación de población">Población: OFF</button>
              <button class="btn" id="btnExplainGB" title="Ir a la explicación">Explicación</button>
</div>

        

        
  <div class="footerSingle">
          <span class="footerSource">Fuente: <span style="color:#fff">BM</span> (PIB/IPC), <span style="color:#fff">INE</span> (población), <span style="color:#fff">PGE</span> (gasto). Precios de 1986. · <span style="opacity:.9;">N.Geolitics</span></span>
          <span class="footerPres">Felipe González (1986–1996) · José María Aznar (1996–2004) · José Luis Rodríguez Zapatero (2004–2011) · Mariano Rajoy (2011–2018) · Pedro Sánchez (2018–2023)</span>
        </div>

        
        
        

        </div>
      </section>
    </div>

    <section class="panel">
      <div class="ph">
        <div class="ttl">Explicación</div>
        <div class="sub"></div>
      </div>
      <div class="pc">
      <div class="popBox" id="gbPopBox" style="display:none;">
                <div class="popTitle">Población total (INE)</div>
                <div class="popTableScroll">
                  <table class="popTable" aria-label="Tabla de población total por año">
                    <thead>
                      <tr><th>Año</th><th>Población total</th></tr>
                    </thead>
                    <tbody id="gbPopBody"></tbody>
                  </table>
                </div>
              </div>
      <div class="explainBox" id="gbExplain">
                <div class="explainTitle">Cómo leer estas series</div>
                <div class="explainText">
                  <div><b>PIB total</b> y <b>Gasto público total</b> están en euros reales de 1986 (miles de millones).</div>
                  <div><b>Per cápita</b> significa “por persona”: se divide entre la <b>población total</b> del año.</div>
                  <div style="margin-top:8px;">
                    Reglas rápidas:
                    <ul>
                      <li>Si el <b>gasto total</b> crece igual que la <b>población</b> → <b>gasto per cápita</b> se mantiene plano.</li>
                      <li>Si la <b>población</b> crece más rápido que el <b>gasto</b> → <b>gasto per cápita</b> baja.</li>
                      <li>Si el <b>gasto</b> crece más rápido que la <b>población</b> → <b>gasto per cápita</b> sube.</li>
                    </ul>
                  </div>
                  <div style="margin-top:6px; opacity:.95;">
                    Tip: pasa el cursor por los porcentajes de cada mandato (PIB / PIB pc / Gto / Gto pc) para resaltar en el gráfico <b>solo ese tramo temporal</b>.
                  </div>
                </div>
              </div>
      </div>
    </section>
  </main>

<!-- ===================== VISTA 3: Presión fiscal ===================== -->
  <main id="viewPA" class="view">
    <div class="topGrid">
      <section class="panel">
        <div class="ph">
          <div class="ttl">Serie</div>
          <div class="sub">1986–2023</div>
        </div>
        <div class="pc">
          <div class="legend" id="legendPA"></div>
        </div>
      </section>

      <section class="panel">
        <div class="ph">
          <div class="ttl">Gráfico</div>
          <div class="sub"></div>
        </div>

        <div class="pc chartPc">
          <div class="svgWrap" id="svgWrapPA">
            <svg id="chartSvgPA" class="chartSvg" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Gráfico de presión fiscal como porcentaje del PIB"></svg>
            <div class="tooltip" id="tooltipPA" style="display:none;"></div>
            <div class="errorBox" id="errorBoxPA" style="display:none;"></div>
          </div>

          <div class="chartControls">
            <button class="btn on" id="btnPolBandsPA" title="Mostrar/ocultar colores de presidencias">Políticos: ON</button>
            <button class="btn" id="btnExplainPA" title="Ir a la explicación">Explicación</button>
  </div>

        

        
  <div class="footerSingle">
          <span class="footerSource">Fuente: <span style="color:#fff">Banco Mundial</span>, <span style="color:#fff">INE</span>, <span style="color:#fff">BOE</span>, <span style="color:#fff">FRED</span>. · <span style="opacity:.9;">N.Geolitics</span></span>
          <span class="footerPres">Felipe González (1986–1996) · José María Aznar (1996–2004) · José Luis Rodríguez Zapatero (2004–2011) · Mariano Rajoy (2011–2018) · Pedro Sánchez (2018–2023)</span>
        </div>
        

        </div>
      </section>
    </div>

    <section class="panel">
      <div class="ph">
        <div class="ttl">Explicación</div>
        <div class="sub"></div>
      </div>
      <div class="pc">
      <div class="explainBox" id="paExplain">
                <div class="explainTitle">Qué mide la “presión fiscal” aquí</div>
                <div class="explainText">
                  <div>El CSV <code>indicadores_estado_a_1986.csv</code> ya trae la serie en porcentaje: <code>presion_fiscal_real_1986_pct</code>.
                  <div style="margin-top:8px;">En esta sección mostramos 3 series del CSV:</div>
                  <ul style="margin:6px 0 0 18px; padding:0; line-height:1.45;">
                    <li><code>presion_fiscal_real_1986_pct</code> (Presión fiscal, % del PIB real 1986)</li>
                    <li><code>gasto_publico_per_capita_pct_1986</code> (Presión de gasto público, % del PIB real per cápita 1986)</li>
                    <li><code>esfuerzo_fiscal_simple</code> (Esfuerzo fiscal simple, índice; se dibuja en el eje derecho)</li>
                  </ul></div>
                  <div style="margin-top:8px;">
                    La interpretación es:
                    <div style="margin:6px 0 0 0;"><b>Presión fiscal (%)</b> = 100 × ( <b>Ingresos fiscales reales (1986)</b> ÷ <b>PIB real (1986)</b> )</div>
                    <div style="opacity:.95; margin-top:6px;">
                      Donde “ingresos fiscales” suelen recoger impuestos + cotizaciones sociales (según las fuentes del propio CSV).
                    </div>
                  </div>
                  <div style="margin-top:8px;">
                    Nota: aquí lo mostramos tal cual viene en el CSV para asegurar coherencia y evitar recalcular con supuestos distintos.
                  </div>
                </div>
              </div>
</div>
      </div>
    </section>
  </main>

<script>
/* ===================== Tabs ===================== */
(function(){
  const btns = Array.from(document.querySelectorAll(".tabs .btn.tab"));
  const views = {
    pge: document.getElementById("viewPGE"),
    gb:  document.getElementById("viewGB"),
    pa:  document.getElementById("viewPA"),
};

  function setView(k){
    for (const [key, el] of Object.entries(views)){
      el.classList.toggle("active", key === k);
    }
    for (const b of btns){
      const on = b.dataset.view === k;
      b.classList.toggle("on", on);
      b.setAttribute("aria-selected", on ? "true" : "false");
    }
    // Al cambiar de sección, empieza arriba (la explicación queda más abajo y se ve con scroll)
    if (views[k]) views[k].scrollTop = 0;

    // Guardar sección actual (sirve para dibujar cuando el controlador aún está cargando)
    window.__activeViewKey = k;

    // Recalcular geometría de gráficos visibles (tras aplicar display/layout)
    requestAnimationFrame(() => {
      if (k === "pge") window.__pge?.onShow?.();
      if (k === "gb")  window.__gb?.onShow?.();
      if (k === "pa")  window.__pa?.onShow?.();
});
  }

  btns.forEach(b => b.addEventListener("click", () => setView(b.dataset.view)));
  setView("pge");
})();


/* ===================== Presidencias (bandas de fondo y resumen) ===================== */
const PRES_BANDS = [
  { name:"Felipe González", start:1982, end:1996, color:"#552222" },
  { name:"José María Aznar", start:1996, end:2004, color:"#223C66" },
  { name:"José Luis Rodríguez Zapatero", start:2004, end:2011, color:"#552222" },
  { name:"Mariano Rajoy", start:2011, end:2018, color:"#223C66" },
  { name:"Pedro Sánchez", start:2018, end:null, color:"#552222" },
];

// Periodos (para el bloque-resumen) ya recortados a tus datos 1986–2023
const PRES_PERIODS = [
  { name:"Felipe González", start:1986, end:1996 },
  { name:"José María Aznar", start:1996, end:2004 },
  { name:"José Luis Rodríguez Zapatero", start:2004, end:2011 },
  { name:"Mariano Rajoy", start:2011, end:2018 },
  { name:"Pedro Sánchez", start:2018, end:2023 },
];

/* ===================== Helpers comunes ===================== */
function stripAccentsLower(s){
  if (s === null || s === undefined) return "";
  return String(s)
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .replace(/\s+/g, " ")
    .trim();
}
function normHeader(s){
  return stripAccentsLower(s)
    .replace(/[\s_\t\u00a0]/g,"")
    .replace(/[^\p{L}\p{N}]/gu,"");
}
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function toNum(v){
  if (v === null || v === undefined) return NaN;
  let s = String(v).trim();
  if (!s) return NaN;

  // remove spaces / NBSP
  s = s.replace(/[\s\u00a0]/g, "");

  const hasComma = s.includes(",");
  const hasDot = s.includes(".");

  if (hasComma && hasDot){
    const lastComma = s.lastIndexOf(",");
    const lastDot = s.lastIndexOf(".");
    const decSep = (lastComma > lastDot) ? "," : ".";
    const thouSep = (decSep === ",") ? "." : ",";
    s = s.split(thouSep).join("");
    s = s.replace(decSep, ".");
  } else if (hasComma){
    const parts = s.split(",");
    if (parts.length > 2){
      const dec = parts.pop();
      s = parts.join("") + "." + dec;
    } else {
      const a = parts[0];
      const b = parts[1] ?? "";
      // if looks like decimal (1-3 digits), treat as decimal; else treat comma as thousands sep
      if (b.length > 0 && b.length <= 3){
        s = a.replace(/\./g, "") + "." + b;
      } else {
        s = parts.join("");
      }
    }
  } else if (hasDot){
    const parts = s.split(".");
    if (parts.length > 2){
      const dec = parts.pop();
      s = parts.join("") + "." + dec;
    } else {
      s = s.replace(/,/g, "");
    }
  }

  const x = Number(s);
  return Number.isFinite(x) ? x : NaN;
}
function createSvgEl(tag, attrs={}){
  const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
  for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, String(v));
  return el;
}
async function fetchText(url){
  const r = await fetch(url, { cache: "no-store" });
  if (!r.ok) throw new Error(`No se pudo cargar ${url} (HTTP ${r.status})`);
  return await r.text();
}
function parseCSV(text){
  const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n").filter(l => l.trim().length);
  if (!lines.length) return { headers: [], rows: [] };

  const seps = [",",";","\t","|"];
  function scoreSep(sep){
    let score = 0;
    for (let i=0;i<Math.min(12, lines.length);i++){
      score += (lines[i].match(new RegExp("\\"+sep, "g"))||[]).length;
    }
    return score;
  }
  let sep = ",";
  let best = -1;
  for (const s of seps){
    const sc = scoreSep(s);
    if (sc > best){ best = sc; sep = s; }
  }

  function splitCSVLine(line){
    const out = [];
    let cur = "";
    let inQ = false;
    for (let i=0;i<line.length;i++){
      const ch = line[i];
      if (inQ){
        if (ch === '"'){
          if (line[i+1] === '"'){ cur += '"'; i++; }
          else inQ = false;
        } else cur += ch;
      } else {
        if (ch === '"') inQ = true;
        else if (ch === sep){ out.push(cur); cur=""; }
        else cur += ch;
      }
    }
    out.push(cur);
    return out;
  }

  const headers = splitCSVLine(lines[0]).map(h => h.trim());
  const rows = [];
  for (let i=1;i<lines.length;i++){
    const cols = splitCSVLine(lines[i]);
    const row = {};
    for (let j=0;j<headers.length;j++){
      row[headers[j]] = (cols[j] ?? "").trim();
    }
    rows.push(row);
  }
  return { headers, rows };
}
function pickCol(headers, candidates){
  const map = new Map(headers.map(h => [normHeader(h), h]));
  for (const c of candidates){
    const k = normHeader(c);
    if (map.has(k)) return map.get(k);
  }
  for (const [k, orig] of map.entries()){
    for (const c of candidates){
      if (k.includes(normHeader(c))) return orig;
    }
  }
  return null;
}
function niceStepX(span){
  if (span <= 10) return 1;
  if (span <= 20) return 2;
  if (span <= 40) return 5;
  return 10;
}
function niceStepY(span){
  if (span <= 2) return 0.2;
  if (span <= 5) return 0.5;
  if (span <= 10) return 1;
  if (span <= 20) return 2;
  if (span <= 50) return 5;
  if (span <= 100) return 10;
  if (span <= 200) return 20;
  if (span <= 500) return 50;
  return 100;
}
function computeXTicks(minYear, maxYear){
  const step = niceStepX(maxYear - minYear);
  const start = Math.ceil(minYear/step)*step;
  const out = [];
  for (let y=start; y<=maxYear+1e-9; y+=step) out.push(y);
  if (out[0] !== minYear) out.unshift(minYear);
  if (out[out.length-1] !== maxYear) out.push(maxYear);
  return Array.from(new Set(out)).sort((a,b)=>a-b);
}
function makeHSVColor(i, n){
  const h = (i / Math.max(1,n)) * 360;
  const s = 0.78, v = 0.98;
  const c = v * s;
  const x = c * (1 - Math.abs(((h/60) % 2) - 1));
  const m = v - c;
  let r=0,g=0,b=0;
  if (h < 60){ r=c; g=x; b=0; }
  else if (h < 120){ r=x; g=c; b=0; }
  else if (h < 180){ r=0; g=c; b=x; }
  else if (h < 240){ r=0; g=x; b=c; }
  else if (h < 300){ r=x; g=0; b=c; }
  else { r=c; g=0; b=x; }
  r = Math.round((r+m)*255);
  g = Math.round((g+m)*255);
  b = Math.round((b+m)*255);
  return `rgb(${r},${g},${b})`;
}

/* Curva suave Catmull-Rom -> Bézier (con clamping de overshoot) */
function buildSmoothPathFromPoints(pts){
  if (!pts || pts.length < 2) return "";
  function clampCtrlY(cy, y1, y2){
    const mn = Math.min(y1, y2);
    const mx = Math.max(y1, y2);
    const span = mx - mn;
    if (span < 1e-6) return cy;
    return clamp(cy, mn - 0.25*span, mx + 0.25*span);
  }
  let d = `M ${pts[0].x.toFixed(2)} ${pts[0].y.toFixed(2)}`;
  for (let i=0;i<pts.length-1;i++){
    const p0 = (i-1 >= 0) ? pts[i-1] : pts[i];
    const p1 = pts[i];
    const p2 = pts[i+1];
    const p3 = (i+2 < pts.length) ? pts[i+2] : p2;

    let c1x = p1.x + (p2.x - p0.x) / 6;
    let c1y = p1.y + (p2.y - p0.y) / 6;
    let c2x = p2.x - (p3.x - p1.x) / 6;
    let c2y = p2.y - (p3.y - p1.y) / 6;

    c1y = clampCtrlY(c1y, p1.y, p2.y);
    c2y = clampCtrlY(c2y, p1.y, p2.y);

    d += ` C ${c1x.toFixed(2)} ${c1y.toFixed(2)} ${c2x.toFixed(2)} ${c2y.toFixed(2)} ${p2.x.toFixed(2)} ${p2.y.toFixed(2)}`;
  }
  return d;
}

function lowerBound(arr, x){
  let lo=0, hi=arr.length;
  while (lo<hi){
    const mid = (lo+hi)>>1;
    if (arr[mid] < x) lo = mid+1;
    else hi = mid;
  }
  return lo;
}
function interpAtYear(series, year){
  const xs = series.xs;
  const ys = series.ys;
  if (!xs || xs.length === 0) return null;
  if (year < xs[0] || year > xs[xs.length-1]) return null;
  const i = lowerBound(xs, year);
  if (i < xs.length && xs[i] === year){
    const v = ys[i];
    return Number.isFinite(v) ? v : null;
  }
  const i1 = i;
  const i0 = i-1;
  if (i0 < 0 || i1 >= xs.length) return null;
  const x0 = xs[i0], x1 = xs[i1];
  const y0 = ys[i0], y1 = ys[i1];
  if (!Number.isFinite(y0) || !Number.isFinite(y1)) return null;

  // Evita interpolar a través de huecos (si falta algún año intermedio)
  if ((x1 - x0) > 1) return null;

  const t = (year - x0) / (x1 - x0);
  return y0 + t * (y1 - y0);
}

/* ===================== Chart controller (SVG) ===================== */
function makeChartController(opts){
  const {
    svg, wrap, tooltipEl, errorEl,
    legendEl,
    controls,
    seriesList,
    getValueAtYear,
    getSeriesForPath,
    xDomain,
    yDomain,
    formatValue,
    extraBackground,
    extraAnnotations,
    yTickBuilder,
    rightAxis,
    yLabelLeft,
    yLabelRight,
    yLabelLeftMarkers,
    yLabelRightMarkers,
    defaultOrderTooltip,
    topN,
    valueSorter,
    alwaysTooltip,
    segmentBreakRule,
    forceBreakAfterYears,
  } = opts;

  const state = {
    focusSet: null,
    hoverKey: null,
    hoverFocusMode: false,
    crosshairMode: ((window.matchMedia && window.matchMedia("(pointer:coarse)").matches) ? true : false),
    scaleMode: "exp",
    highlight: null, // {start,end,keys:Array<string>}
    pathEls: new Map(),
    itemEls: new Map(),
    geom: null,
    rafPending: false,
    lastPointer: null,
    lastFocusKey: "",
    __bindings: [],
    __clipSeq: 0,
    __t: null,
  };

  function bind(el, type, fn){
    if (!el) return;
    el.addEventListener(type, fn);
    state.__bindings.push([el, type, fn]);
  }
  function bindWindow(type, fn){
    window.addEventListener(type, fn);
    state.__bindings.push([window, type, fn]);
  }


  function focusKey(set){
    if (!set || !set.size) return "";
    return Array.from(set).sort().join("|");
  }
  function getActiveFocusSet(){
    if (state.focusSet && state.focusSet.size) return state.focusSet;
    if (state.hoverFocusMode && state.hoverKey) return new Set([state.hoverKey]);
    return null;
  }
  function applyFocusStyles(force=false){
    const set = getActiveFocusSet();
    const key = focusKey(set);
    if (!force && key === state.lastFocusKey) return;
    state.lastFocusKey = key;

    const hasFocus = !!(set && set.size);
    const hk = (state.highlight && state.highlight.keys && state.highlight.keys.length) ? new Set(state.highlight.keys) : null;
    for (const s of seriesList){
      const k = s.key;
      const path = state.pathEls.get(k);
      const it = state.itemEls.get(k);
      const on = !hasFocus || set.has(k);
      let baseOp = on ? 1.0 : 0.12;
      let sw = on ? 2.35 : 1.6;
      if (hk){
        if (!hk.has(k)){
          baseOp = Math.min(baseOp, 0.10);
          sw = Math.min(sw, 1.4);
        } else {
          baseOp = Math.min(baseOp, 0.35);
        }
      }
      if (path){
        path.setAttribute("opacity", String(baseOp));
        path.setAttribute("stroke-width", String(sw));
      }
      if (it){
        it.classList.toggle("muted", !on);
      }
    }
  }
  function toggleFocusKey(k, additive){
    if (!additive){
      if (state.focusSet && state.focusSet.size === 1 && state.focusSet.has(k)) state.focusSet = null;
      else state.focusSet = new Set([k]);
    } else {
      if (!state.focusSet) state.focusSet = new Set();
      if (state.focusSet.has(k)) state.focusSet.delete(k);
      else state.focusSet.add(k);
      if (state.focusSet.size === 0) state.focusSet = null;
    }
    applyFocusStyles(true);
  }

  function yTransform(v){
    if (!Number.isFinite(v)) return NaN;
    if (state.scaleMode === "log") return Math.log10(1 + Math.max(0, v));
    return v;
  }

  function computeYTicksLeft(ymax){
    if (yTickBuilder) return yTickBuilder("left", ymax);
    const step = niceStepY(ymax);
    const yTop = Math.ceil(ymax/step)*step;
    const out = [];
    for (let v=0; v<=yTop+1e-9; v+=step) out.push(v);
    return out;
  }

  function showError(msg){
    if (!errorEl) return;
    errorEl.style.display = "flex";
    errorEl.textContent = msg;
  }
  function hideError(){
    if (!errorEl) return;
    errorEl.style.display = "none";
    errorEl.textContent = "";
  }

  function buildLegend(){
    legendEl.innerHTML = "";
    state.itemEls.clear();

    for (const s of seriesList){
      const el = document.createElement("div");
      el.className = "item";
      el.dataset.key = s.key;

      const sw = document.createElement("div");
      sw.className = "sw";
      sw.style.background = s.color;

      const nm = document.createElement("div");
      nm.className = "nm";
      nm.textContent = s.label;

      el.appendChild(sw);
      el.appendChild(nm);

      if (s.badge){
        const bd = document.createElement("div");
        bd.className = "badge";
        bd.textContent = s.badge;
        el.appendChild(bd);
      }

      el.addEventListener("click", (ev) => {
        toggleFocusKey(s.key, ev.shiftKey);
      });

      legendEl.appendChild(el);
      state.itemEls.set(s.key, el);
    }
  }

  function draw(){
    hideError();
    const rect = wrap.getBoundingClientRect();
    const w = Math.max(320, Math.floor(rect.width));
    const h = Math.max(320, Math.floor(rect.height));

    svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
    svg.setAttribute("preserveAspectRatio", "none");
    while (svg.firstChild) svg.removeChild(svg.firstChild);

    const margin = { l: 64, r: (yLabelRight ? 64 : 18), t: 18, b: 54 };
    const plotW = Math.max(10, w - margin.l - margin.r);
    const plotH = Math.max(10, h - margin.t - margin.b);
    const plotRect = { x: margin.l, y: margin.t, w: plotW, h: plotH };

    const xScale = (year) => {
      const t = (year - xDomain.min) / (xDomain.max - xDomain.min || 1);
      return margin.l + t * plotW;
    };

    const yTicksLeft = computeYTicksLeft(yDomain.left.max);
    const yValsT = yTicksLeft.map(v => yTransform(v));
    const yMinT = Math.min(...yValsT.filter(Number.isFinite));
    const yMaxT = Math.max(...yValsT.filter(Number.isFinite));
    const yScaleLeftT = (vT) => {
      const t = (vT - yMinT) / (yMaxT - yMinT || 1);
      return margin.t + plotH - t * plotH;
    };

    // Right axis mapping (optional)
    let mapRightToLeftT = null;
    let rightTicks = null;
    if (rightAxis){
      rightTicks = rightAxis.ticks;
      const rTicksT = rightTicks.map(v => yTransform(v)).filter(Number.isFinite);
      const rMinT = Math.min(...rTicksT);
      const rMaxT = Math.max(...rTicksT);
      mapRightToLeftT = (yrT) => {
        const alpha = (yrT - rMinT) / (rMaxT - rMinT || 1);
        return yMinT + alpha * (yMaxT - yMinT);
      };
    }

    const defs = createSvgEl("defs");

    const gBg = createSvgEl("g");
    const gGrid = createSvgEl("g");
    const gAxes = createSvgEl("g");
    const gLines = createSvgEl("g");
    const gOverlay = createSvgEl("g");
    const gHi = createSvgEl("g");
    const gAnn = createSvgEl("g");

    if (extraBackground) extraBackground(gBg, xScale, plotRect);

    // Grid + x ticks
    const xTicks = computeXTicks(xDomain.min, xDomain.max);
    for (const yr of xTicks){
      const x = xScale(yr);
      gGrid.appendChild(createSvgEl("line", { x1:x, y1:margin.t, x2:x, y2:margin.t+plotH, stroke:"rgba(74,74,74,.38)", "stroke-width":1 }));
      const t = createSvgEl("text", { x:x, y: margin.t+plotH+18, fill:"rgba(176,176,176,.95)", "text-anchor":"middle", "font-size":12, "font-family":"Arial, system-ui, sans-serif" });
      t.textContent = yr;
      gAxes.appendChild(t);
    }
    // y ticks left
    for (const tv of yTicksLeft){
      const y = yScaleLeftT(yTransform(tv));
      gGrid.appendChild(createSvgEl("line", { x1:margin.l, y1:y, x2:margin.l+plotW, y2:y, stroke:"rgba(74,74,74,.38)", "stroke-width":1 }));
      const tx = createSvgEl("text", { x: margin.l-10, y: y+4, fill:"rgba(176,176,176,.95)", "text-anchor":"end", "font-size":12, "font-family":"Arial, system-ui, sans-serif" });
      tx.textContent = String(tv);
      gAxes.appendChild(tx);
    }

    // Right axis
    if (rightAxis){
      const rightX = margin.l + plotW;
      gAxes.appendChild(createSvgEl("line", { x1:rightX, y1:margin.t, x2:rightX, y2:margin.t+plotH, stroke:"rgba(176,176,176,.7)", "stroke-width":1.25 }));
      for (const tv of rightTicks){
        const yR = yTransform(tv);
        const yL = mapRightToLeftT(yR);
        const y = yScaleLeftT(yL);
        gGrid.appendChild(createSvgEl("line", { x1:rightX, y1:y, x2:rightX-8, y2:y, stroke:"rgba(176,176,176,.7)", "stroke-width":1 }));
        const tx = createSvgEl("text", { x: rightX+10, y: y+4, fill:"rgba(176,176,176,.95)", "text-anchor":"start", "font-size":12, "font-family":"Arial, system-ui, sans-serif" });
        tx.textContent = rightAxis.formatTick ? rightAxis.formatTick(tv) : String(tv);
        gAxes.appendChild(tx);
      }
    }

    // Axes base
    gAxes.appendChild(createSvgEl("line", { x1: margin.l, y1: margin.t+plotH, x2: margin.l+plotW, y2: margin.t+plotH, stroke:"rgba(176,176,176,.7)", "stroke-width":1.25 }));
    gAxes.appendChild(createSvgEl("line", { x1: margin.l, y1: margin.t, x2: margin.l, y2: margin.t+plotH, stroke:"rgba(176,176,176,.7)", "stroke-width":1.25 }));

    // Labels
    const xTitle = createSvgEl("text", { x: margin.l + plotW/2, y: margin.t+plotH+42, fill:"rgba(176,176,176,.95)", "text-anchor":"middle", "font-size":13, "font-family":"Arial, system-ui, sans-serif" });
    xTitle.textContent = "Año";
    gAxes.appendChild(xTitle);

    const yTitle = createSvgEl("text", {
      x: 18, y: margin.t + plotH/2, fill:"rgba(176,176,176,.95)",
      "text-anchor":"middle", "font-size":13, "font-family":"Arial, system-ui, sans-serif",
      transform: `rotate(-90 18 ${margin.t + plotH/2})`
    });
    if (yLabelLeftMarkers && yLabelLeftMarkers.length){
      yTitle.textContent = "";
      const t0 = createSvgEl("tspan", {});
      t0.textContent = yLabelLeft || "";
      yTitle.appendChild(t0);
      for (const col of yLabelLeftMarkers){
        const t = createSvgEl("tspan", { fill: col, dx: 8 });
        t.textContent = "●";
        yTitle.appendChild(t);
      }
    } else {
      yTitle.textContent = yLabelLeft || "";
    }
    gAxes.appendChild(yTitle);

    if (yLabelRight){
      const rx = w - 18;
      const yTitleR = createSvgEl("text", {
        x: rx, y: margin.t + plotH/2, fill:"rgba(176,176,176,.95)",
        "text-anchor":"middle", "font-size":13, "font-family":"Arial, system-ui, sans-serif",
        transform: `rotate(90 ${rx} ${margin.t + plotH/2})`
      });
      if (yLabelRightMarkers && yLabelRightMarkers.length){
        yTitleR.textContent = "";
        const t0r = createSvgEl("tspan", {});
        t0r.textContent = yLabelRight;
        yTitleR.appendChild(t0r);
        for (const col of yLabelRightMarkers){
          const tr = createSvgEl("tspan", { fill: col, dx: 8 });
          tr.textContent = "●";
          yTitleR.appendChild(tr);
        }
      } else {
        yTitleR.textContent = yLabelRight;
      }
      gAxes.appendChild(yTitleR);
    }

    // Lines
    state.pathEls.clear();
    for (const s of seriesList){
      const ser = getSeriesForPath(s.key);
      if (!ser || !ser.xs || ser.xs.length < 2) continue;

      const dParts = [];
      let segPts = [];
      let prevYear = null;

      function flushSeg(){
        if (segPts.length >= 2){
          const dd = buildSmoothPathFromPoints(segPts);
          if (dd) dParts.push(dd);
        }
        segPts = [];
      }

      for (let i=0;i<ser.xs.length;i++){
        const year = ser.xs[i];
        const v = ser.ys[i];

        if (!Number.isFinite(year) || !Number.isFinite(v)){
          flushSeg();
          prevYear = null;
          continue;
        }

        // Segmentación: por defecto cortamos cuando falta algún año intermedio.
        // Opcionalmente:
        //  - segmentBreakRule(key, prevYear, nextYear, gap, series) puede permitir continuidad (p.ej. años sin PGE)
        //  - forceBreakAfterYears fuerza cortes incluso entre años consecutivos (p.ej. 2004→2005)
        if (prevYear !== null){
          const gap = year - prevYear;
          let mustBreak = false;

          if (gap > 1){
            if (typeof segmentBreakRule === "function"){
              mustBreak = !!segmentBreakRule(s.key, prevYear, year, gap, ser);
            } else {
              mustBreak = true;
            }
          } else if (gap === 1 && forceBreakAfterYears && forceBreakAfterYears.has(prevYear)){
            mustBreak = true;
          }

          if (mustBreak) flushSeg();
        }

        const x = xScale(year);

        let y;
        if (s.axis === "right" && rightAxis && mapRightToLeftT){
          const yrT = yTransform(v);
          const ylT = mapRightToLeftT(yrT);
          y = yScaleLeftT(ylT);
        } else {
          y = yScaleLeftT(yTransform(v));
        }

        if (!Number.isFinite(x) || !Number.isFinite(y)){
          flushSeg();
          prevYear = null;
          continue;
        }

        segPts.push({x,y});
        prevYear = year;
      }
      flushSeg();

      const d = dParts.join(" ");
      if (!d) continue;


      const path = createSvgEl("path", {
        d, fill:"none",
        stroke: s.color,
        "stroke-width": 2.0,
        "stroke-linejoin":"round",
        "stroke-linecap":"round",
        "vector-effect":"non-scaling-stroke",
        opacity: 1.0,
        "data-key": s.key,
        style: "pointer-events:none;"
      });

      state.pathEls.set(s.key, path);
      gLines.appendChild(path);
    }
    // Highlight window (externo) - atenúa fuera del rango y remarca tramo/serie
    if (state.highlight && state.highlight.start !== null && state.highlight.end !== null){
      const hs = clamp(state.highlight.start, xDomain.min, xDomain.max);
      const he = clamp(state.highlight.end, xDomain.min, xDomain.max);
      const startY = Math.min(hs, he);
      const endY = Math.max(hs, he);
      const x0 = xScale(startY);
      const x1 = xScale(endY);

      const leftW = Math.max(0, x0 - margin.l);
      const rightW = Math.max(0, (margin.l + plotW) - x1);

      if (leftW > 0){
        gHi.appendChild(createSvgEl("rect", {
          x: margin.l, y: margin.t, width: leftW, height: plotH,
          fill: "rgba(0,0,0,.55)", opacity: 0.28
        }));
      }
      if (rightW > 0){
        gHi.appendChild(createSvgEl("rect", {
          x: x1, y: margin.t, width: rightW, height: plotH,
          fill: "rgba(0,0,0,.55)", opacity: 0.28
        }));
      }

      gHi.appendChild(createSvgEl("line", { x1:x0, y1:margin.t, x2:x0, y2:margin.t+plotH, stroke:"rgba(254,247,2,.55)", "stroke-width":1.5, "vector-effect":"non-scaling-stroke" }));
      gHi.appendChild(createSvgEl("line", { x1:x1, y1:margin.t, x2:x1, y2:margin.t+plotH, stroke:"rgba(254,247,2,.55)", "stroke-width":1.5, "vector-effect":"non-scaling-stroke" }));

      const clipId = "hlClip_" + (++state.__clipSeq);
      const cp = createSvgEl("clipPath", { id: clipId });
      cp.appendChild(createSvgEl("rect", { x:x0, y:margin.t, width: Math.max(0, x1-x0), height: plotH }));
      defs.appendChild(cp);

      const keys = (state.highlight.keys && state.highlight.keys.length)
        ? state.highlight.keys
        : seriesList.map(s => s.key);

      for (const k of keys){
        const basePath = state.pathEls.get(k);
        if (!basePath) continue;
        const dAttr = basePath.getAttribute("d");
        if (!dAttr) continue;

        const sMeta = seriesList.find(s => s.key === k);
        const col = sMeta ? sMeta.color : "rgba(254,247,2,.95)";

        const hlPath = createSvgEl("path", {
          d: dAttr, fill:"none", stroke: col,
          "stroke-width": 3.35, "stroke-linejoin":"round", "stroke-linecap":"round",
          "vector-effect":"non-scaling-stroke",
          opacity: 1.0,
          style: "pointer-events:none;",
          "clip-path": `url(#${clipId})`
        });
        gHi.appendChild(hlPath);

        // marcadores inicio/fin (si podemos interpolar el valor en esos años)
        const ser = getSeriesForPath(k);
        if (ser){
          const vA = interpAtYear(ser, startY);
          const vB = interpAtYear(ser, endY);
          const axis = sMeta?.axis || "left";

          function mapY(v){
            if (v === null || !Number.isFinite(v)) return null;
            if (axis === "right" && rightAxis && mapRightToLeftT){
              const yrT = yTransform(v);
              const ylT = mapRightToLeftT(yrT);
              return yScaleLeftT(ylT);
            }
            return yScaleLeftT(yTransform(v));
          }

          const yA = mapY(vA);
          const yB = mapY(vB);
          if (yA !== null && Number.isFinite(yA)){
            gHi.appendChild(createSvgEl("circle", { cx:x0, cy:yA, r:4.25, fill:col, stroke:"rgba(0,0,0,.65)", "stroke-width":1 }));
          }
          if (yB !== null && Number.isFinite(yB)){
            gHi.appendChild(createSvgEl("circle", { cx:x1, cy:yB, r:4.25, fill:col, stroke:"rgba(0,0,0,.65)", "stroke-width":1 }));
          }
        }
      }
    }


    // Extra annotations (optional)
    if (extraAnnotations){
      extraAnnotations(gAnn, { w,h, margin, plotRect, plotW, plotH, xScale, yScaleLeftT, yTransform, mapRightToLeftT, xDomain });
    }

    // Overlay
    const crosshair = createSvgEl("line", {
      x1: margin.l, y1: margin.t, x2: margin.l, y2: margin.t+plotH,
      stroke: "rgba(254,247,2,.55)", "stroke-width": 1.5,
      opacity: 0, "vector-effect":"non-scaling-stroke"
    });
    const dot = createSvgEl("circle", {
      cx: margin.l, cy: margin.t, r: 4.5,
      fill: "rgba(254,247,2,.95)", stroke: "rgba(0,0,0,.55)",
      "stroke-width": 1, opacity: 0
    });
    const hit = createSvgEl("rect", {
      x: margin.l, y: margin.t, width: plotW, height: plotH,
      fill: "rgba(0,0,0,0)", style: "cursor:crosshair;"
    });

    gOverlay.appendChild(crosshair);
    gOverlay.appendChild(dot);
    gOverlay.appendChild(hit);

    svg.appendChild(defs);
    svg.appendChild(gBg);
    svg.appendChild(gGrid);
    svg.appendChild(gAxes);
    svg.appendChild(gLines);
    svg.appendChild(gHi);
    svg.appendChild(gAnn);
    svg.appendChild(gOverlay);

    state.geom = { w,h, margin, plotW, plotH, xScale, yScaleLeftT, yTransform, mapRightToLeftT, crosshair, dot, hit };

    function localXY(ev){
      const b = svg.getBoundingClientRect();
      const x = (ev.clientX - b.left) * (w / b.width);
      const y = (ev.clientY - b.top) * (h / b.height);
      return {x,y};
    }
    function nearestYearFromX(x){
      const t = clamp((x - margin.l) / (plotW || 1), 0, 1);
      const year = Math.round(xDomain.min + t * (xDomain.max - xDomain.min));
      return clamp(year, xDomain.min, xDomain.max);
    }

    function renderHover(pt){
      const year = nearestYearFromX(pt.x);

      let hoverKey = null;
      let bestDist = Infinity;
      let bestY = null;

      for (const s of seriesList){
        const ser = getSeriesForPath(s.key);
        if (!ser) continue;
        const v = interpAtYear(ser, year);
        if (v === null) continue;

        let y;
        if (s.axis === "right" && rightAxis && state.geom.mapRightToLeftT){
          const yrT = yTransform(v);
          const ylT = state.geom.mapRightToLeftT(yrT);
          y = yScaleLeftT(ylT);
        } else {
          y = yScaleLeftT(yTransform(v));
        }

        const d = Math.abs(y - pt.y);
        if (d < bestDist){
          bestDist = d;
          hoverKey = s.key;
          bestY = y;
        }
      }

      state.hoverKey = hoverKey;

      const showTable = state.crosshairMode || !!alwaysTooltip;

      if (showTable){
        const x = xScale(year);

        if (state.crosshairMode){
          crosshair.setAttribute("x1", x);
          crosshair.setAttribute("x2", x);
          crosshair.setAttribute("opacity", "1");
          dot.setAttribute("opacity", "0");
        } else {
          crosshair.setAttribute("opacity", "0");
          if (hoverKey !== null && bestY !== null){
            dot.setAttribute("cx", x);
            dot.setAttribute("cy", bestY);
            dot.setAttribute("opacity", "1");
          } else {
            dot.setAttribute("opacity", "0");
          }
        }

        // tooltip table
        const rows = [];
        const keys = (defaultOrderTooltip && defaultOrderTooltip.length) ? defaultOrderTooltip : seriesList.map(s=>s.key);
        for (const k of keys){
          const v = getValueAtYear(k, year);
          rows.push({ key:k, v });
        }

        let finalRows = rows;
        if (valueSorter){
          finalRows = rows.slice().sort(valueSorter);
        }
        if (Number.isFinite(topN) && topN > 0 && finalRows.length > topN){
          finalRows = finalRows.slice(0, topN);
        }

        tooltipEl.innerHTML = "";
        const yrEl = document.createElement("div");
        yrEl.className = "ttYear";
        yrEl.textContent = "Año " + year;
        tooltipEl.appendChild(yrEl);

        for (const r of finalRows){
          const s = seriesList.find(x => x.key === r.key);
          const row = document.createElement("div");
          row.className = "ttRow";
          const sw = document.createElement("div");
          sw.className = "ttSw";
          sw.style.background = s ? s.color : "rgba(255,255,255,.4)";
          const nm = document.createElement("div");
          nm.className = "ttName";
          nm.textContent = s ? s.label : r.key;
          const val = document.createElement("div");
          val.className = "ttVal";
          val.textContent = (r.v === null || !Number.isFinite(r.v)) ? "—" : formatValue(r.key, r.v);
          row.appendChild(sw);
          row.appendChild(nm);
          row.appendChild(val);
          tooltipEl.appendChild(row);
        }

        tooltipEl.style.display = "block";

        const pad = 10;
        let left = x + 12;
        let top = (state.crosshairMode || bestY === null) ? (margin.t + 12) : (bestY - 14);

        const tw = clamp(tooltipEl.offsetWidth || 260, 240, 420);
        const th = clamp(tooltipEl.offsetHeight || 180, 80, 420);
        if (left + tw + pad > w) left = x - tw - 12;
        top = clamp(top, margin.t + pad, h - th - pad);
        tooltipEl.style.left = left + "px";
        tooltipEl.style.top = top + "px";

      } else {
        crosshair.setAttribute("opacity", "0");

        if (!hoverKey){
          tooltipEl.style.display = "none";
          dot.setAttribute("opacity", "0");
          applyFocusStyles(false);
          return;
        }

        const x = xScale(year);
        dot.setAttribute("cx", x);
        dot.setAttribute("cy", bestY);
        dot.setAttribute("opacity", "1");

        const s = seriesList.find(x => x.key === hoverKey);
        const v = getValueAtYear(hoverKey, year);
        tooltipEl.innerHTML = "";
        const yrEl = document.createElement("div");
        yrEl.className = "ttYear";
        yrEl.textContent = "Año " + year;
        tooltipEl.appendChild(yrEl);

        const row = document.createElement("div");
        row.className = "ttRow";
        const sw = document.createElement("div");
        sw.className = "ttSw";
        sw.style.background = s ? s.color : "rgba(255,255,255,.4)";
        const nm = document.createElement("div");
        nm.className = "ttName";
        nm.textContent = s ? s.label : hoverKey;
        const val = document.createElement("div");
        val.className = "ttVal";
        val.textContent = (v === null || !Number.isFinite(v)) ? "—" : formatValue(hoverKey, v);
        row.appendChild(sw);
        row.appendChild(nm);
        row.appendChild(val);
        tooltipEl.appendChild(row);

        tooltipEl.style.display = "block";
        let left = x + 12;
        let top = bestY - 14;
        const pad = 10;
        const tw = clamp(tooltipEl.offsetWidth || 260, 240, 420);
        const th = clamp(tooltipEl.offsetHeight || 120, 80, 420);
        if (left + tw + pad > w) left = x - tw - 12;
        top = clamp(top, margin.t + pad, h - th - pad);
        tooltipEl.style.left = left + "px";
        tooltipEl.style.top = top + "px";

        applyFocusStyles(false);
      }

      if (state.hoverFocusMode && !state.focusSet){
        applyFocusStyles(true);
      }
    }

    function onMove(ev){
      state.lastPointer = localXY(ev);
      if (state.rafPending) return;
      state.rafPending = true;
      requestAnimationFrame(() => {
        state.rafPending = false;
        if (!state.lastPointer) return;
        renderHover(state.lastPointer);
      });
    }
    function onLeave(){
      state.lastPointer = null;
      state.hoverKey = null;
      crosshair.setAttribute("opacity", "0");
      dot.setAttribute("opacity", "0");
      tooltipEl.style.display = "none";
      applyFocusStyles(true);
    }

    // Mouse + táctil (Pointer Events). Mantiene compatibilidad con navegadores antiguos.
    hit.addEventListener("pointermove", onMove);
    hit.addEventListener("pointerleave", onLeave);
    hit.addEventListener("pointercancel", onLeave);
    hit.addEventListener("pointerdown", (ev) => {
      try{ hit.setPointerCapture(ev.pointerId); }catch(e){}
      onMove(ev);
    });

    hit.addEventListener("mousemove", onMove);
    hit.addEventListener("mouseleave", onLeave);

    hit.addEventListener("click", (ev) => {
      if (state.hoverKey){
        toggleFocusKey(state.hoverKey, ev.shiftKey);
      }
    });

    applyFocusStyles(true);
  }

  function setControls(){
    if (controls && controls.btnScale){
      bind(controls.btnScale, "click", () => {
        state.scaleMode = (state.scaleMode === "exp") ? "log" : "exp";
        controls.btnScale.textContent = "Escala: " + (state.scaleMode === "log" ? "Logarítmica" : "Exponencial");
        draw();
      });
    }
    if (controls && controls.btnCrosshair){
      // En pantallas táctiles (pointer:coarse) activamos la línea vertical por defecto
      controls.btnCrosshair.textContent = "Línea vertical: " + (state.crosshairMode ? "ON" : "OFF");
      controls.btnCrosshair.classList.toggle("on", state.crosshairMode);

      bind(controls.btnCrosshair, "click", () => {
        state.crosshairMode = !state.crosshairMode;
        controls.btnCrosshair.textContent = "Línea vertical: " + (state.crosshairMode ? "ON" : "OFF");
        controls.btnCrosshair.classList.toggle("on", state.crosshairMode);
        if (!state.crosshairMode){
          tooltipEl.style.display = "none";
        }
      });
    }
    if (controls && controls.btnHoverFocus){
      bind(controls.btnHoverFocus, "click", () => {
        state.hoverFocusMode = !state.hoverFocusMode;
        controls.btnHoverFocus.textContent = "Resaltar al pasar: " + (state.hoverFocusMode ? "ON" : "OFF");
        controls.btnHoverFocus.classList.toggle("on", state.hoverFocusMode);
        applyFocusStyles(true);
      });
    }
    if (controls && controls.btnReset){
      bind(controls.btnReset, "click", () => {
        state.focusSet = null;
        state.hoverKey = null;
        tooltipEl.style.display = "none";
        applyFocusStyles(true);
      });
    }
  }

  buildLegend();
  setControls();
  draw();

  bindWindow("resize", () => {
    clearTimeout(state.__t);
    state.__t = setTimeout(() => draw(), 120);
  });

  function setHighlight(start, end, keys){
    state.highlight = { start, end, keys: Array.isArray(keys) ? keys : null };
    draw();
  }
  function clearHighlight(){
    state.highlight = null;
    draw();
  }
  function destroy(){
    for (const [el, type, fn] of state.__bindings){
      try{ el.removeEventListener(type, fn); } catch(_){}
    }
    state.__bindings.length = 0;
  }

  return {
    onShow: () => draw(),
    setHighlight,
    clearHighlight,
    destroy,
  };
}

/* ===================== Vista 1: PGE (políticas modernas + agregación histórica) ===================== */
(async function(){
  const svg = document.getElementById("chartSvg");
  const wrap = document.getElementById("svgWrap");
  const tooltipEl = document.getElementById("tooltip");
  const errorEl = document.getElementById("errorBox");
  const legendEl = document.getElementById("legend");

  const controls = {
    btnScale: document.getElementById("btnScale"),
    btnCrosshair: document.getElementById("btnCrosshair"),
    btnHoverFocus: document.getElementById("btnHoverFocus"),
  };

  const btnPre2004 = document.getElementById("btnPre2004");
  const btnPolBands = document.getElementById("btnPolBandsPGE");
  const btnExplain = document.getElementById("btnExplainPGE");
  const explainEl = document.getElementById("pgeExplain");
  const mapBodyEl = document.getElementById("pgeMapBody");
  const unmappedNoteEl = document.getElementById("pgeUnmappedNote");

  let showPresBands = true;

  function drawPresBands(gBg, xScale, plotRect){
    if (!showPresBands) return;
    for (const p of PRES_BANDS){
      const x0 = Math.max(app.xDomain.min, p.start);
      const x1 = Math.min(app.xDomain.max, (p.end ?? app.xDomain.max));
      if (x1 <= x0) continue;
      const x = xScale(x0);
      const w = xScale(x1) - xScale(x0);
      gBg.appendChild(createSvgEl("rect", {
        x, y: plotRect.y, width: w, height: plotRect.h,
        fill: p.color, opacity: 0.18
      }));
    }
  }

  if (btnPolBands){
    btnPolBands.classList.toggle("on", showPresBands);
    btnPolBands.textContent = "Políticos: " + (showPresBands ? "ON" : "OFF");
    btnPolBands.addEventListener("click", () => {
      showPresBands = !showPresBands;
      btnPolBands.classList.toggle("on", showPresBands);
      btnPolBands.textContent = "Políticos: " + (showPresBands ? "ON" : "OFF");
      rebuild();
    });
  }

  // Explicación (botón de pulso: hace scroll; no mantiene estado ON/OFF)
  function pulseExplainPGE(){
    if (!explainEl) return;
    requestAnimationFrame(() => {
      const scroller = document.getElementById("viewPGE") || explainEl.closest(".view");
      if (scroller && typeof scroller.scrollTo === "function"){
        const sr = scroller.getBoundingClientRect();
        const tr = explainEl.getBoundingClientRect();
        const top = (tr.top - sr.top) + (scroller.scrollTop || 0) - 8;
        scroller.scrollTo({ top: Math.max(0, top), behavior: "smooth" });
      } else {
        explainEl.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    });
  }

  if (btnExplain){
    btnExplain.classList.remove("on");
    btnExplain.textContent = "Explicación";
    btnExplain.addEventListener("click", pulseExplainPGE);
  }

  // ---------- Helpers ----------
  function normId(v){
    const s = String(v ?? "").trim().toUpperCase();
    if (!s) return "";
    if (/^\d+$/.test(s)) return s.padStart(2, "0");
    return s;
  }

  function parseOldItem(raw){
    const item = String(raw ?? "").trim();
    if (!item) return null;

    let id = "";
    let name = "";

    // Preferimos em dash (—) pero aceptamos "-" si viene así
    if (item.includes("—")){
      const idx = item.indexOf("—");
      id = item.slice(0, idx).trim();
      name = item.slice(idx + 1).trim();
    } else if (item.includes("-")){
      const idx = item.indexOf("-");
      id = item.slice(0, idx).trim();
      name = item.slice(idx + 1).trim();
    } else {
      const m = item.match(/^(\S+)\s+(.*)$/);
      if (m){ id = m[1]; name = m[2]; }
      else { name = item; }
    }

    id = normId(id);
    name = String(name).replace(/^["']|["']$/g, "").trim();
    const nameNorm = stripAccentsLower(name);
    const key = id + "||" + nameNorm;
    return { id, name, key, pretty: (id ? (id + " — " + name) : name) };
  }

  function hsvToRgb(h,s,v){
    let r=0,g=0,b=0;
    const i = Math.floor(h*6);
    const f = h*6 - i;
    const p = v*(1-s);
    const q = v*(1-f*s);
    const t = v*(1-(1-f)*s);
    switch(i%6){
      case 0: r=v; g=t; b=p; break;
      case 1: r=q; g=v; b=p; break;
      case 2: r=p; g=v; b=t; break;
      case 3: r=p; g=q; b=v; break;
      case 4: r=t; g=p; b=v; break;
      case 5: r=v; g=p; b=q; break;
    }
    const rr = Math.round(r*255), gg=Math.round(g*255), bb=Math.round(b*255);
    return `rgb(${rr},${gg},${bb})`;
  }
  function colorList(n, sat=0.9, val=1.0){
    const cols=[];
    for (let i=0;i<n;i++) cols.push(hsvToRgb(i/n, sat, val));
    return cols;
  }

  function formatPct(v){ return Number.isFinite(v) ? (v.toFixed(2) + "%") : "—"; }

  function computeYMax(keys){
    let ymax = 1;
    for (const k of keys){
      const ser = app.seriesByKey.get(k);
      if (!ser) continue;
      for (const v of ser.ys){
        if (Number.isFinite(v)) ymax = Math.max(ymax, v);
      }
    }
    return ymax;
  }

  function yTickBuilder(side, ymax){
    if (side !== "left") return [];
    if (ymax <= 10) return [0,1,2,3,4,5,6,8,10];
    if (ymax <= 20) return [0,2,4,6,8,10,12,15,20];
    if (ymax <= 40) return [0,5,10,15,20,25,30,35,40];
    if (ymax <= 60) return [0,10,20,30,40,50,60];
    return [0,10,20,30,40,50,60,80,100];
  }

  // ---------- Preparación de series ----------
  function prepararSeriesPctModernas(mapCsv, dataCsv){
    const colsMap = mapCsv.headers;
    const rowsMap = mapCsv.rows;

    const c_mod_id  = pickCol(colsMap, ["id_politica_moderno","id politica moderno","id_politica","id politica","id"]);
    const c_mod_pol = pickCol(colsMap, ["politica_moderna","politica moderna","politica","política"]);
    const c_old     = pickCol(colsMap, ["politicas_antiguas_encontradas","politicas antiguas encontradas","politicas_antiguas","politicas antiguas"]);

    if (!c_mod_id || !c_mod_pol || !c_old){
      throw new Error("pge_politicas.csv: faltan columnas esperadas (id_politica_moderno / politica_moderna / politicas_antiguas_encontradas).");
    }

    // 1) Mapping moderno -> lista de (id+nombre) antiguas
    const mapping = [];
    const usedOldKeys = new Set();
    const oldKeyToModern = new Map();

    for (const r of rowsMap){
      const modId = normId(r[c_mod_id]);
      const modLabel = String(r[c_mod_pol] ?? "").trim();
      const oldRaw = String(r[c_old] ?? "").trim();
      if (!modId || !modLabel) continue;

      const pieces = oldRaw ? oldRaw.split("|").map(s => s.trim()).filter(Boolean) : [];
      const olds = [];
      for (const p of pieces){
        const it = parseOldItem(p);
        if (!it || !it.id || !it.name) continue;
        olds.push(it);

        usedOldKeys.add(it.key);
        if (!oldKeyToModern.has(it.key)) oldKeyToModern.set(it.key, []);
        oldKeyToModern.get(it.key).push(modId);
      }

      mapping.push({
        id: modId,
        label: modLabel,
        olds,
      });
    }

    mapping.sort((a,b) => {
      const na = /^\d+$/.test(a.id) ? parseInt(a.id, 10) : 9999;
      const nb = /^\d+$/.test(b.id) ? parseInt(b.id, 10) : 9999;
      return na - nb || a.id.localeCompare(b.id);
    });

    // 2) Agrega datos anuales por (id+política)
    const colsData = dataCsv.headers;
    const rowsData = dataCsv.rows;

    const c_id   = pickCol(colsData, ["id_politica","id politica","id"]);
    const c_year = pickCol(colsData, ["año","ano","anio","year"]);
    const c_pol  = pickCol(colsData, ["politica","política"]);
    const c_val  = pickCol(colsData, ["presupuesto","valor","importe","amount"]);

    if (!c_id || !c_year || !c_pol || !c_val){
      throw new Error("pge_politicas_anio.csv: faltan columnas esperadas (id_politica / anio / politica / presupuesto).");
    }

    const sumByOldKeyYear = new Map(); // oldKey -> Map(year->sum)
    const oldNameByKey = new Map();    // oldKey -> politica (tal cual)
    const totalByYear = new Map();     // year -> total
    const yearsSet = new Set();

    for (const r of rowsData){
      const id = normId(r[c_id]);
      const year = Math.trunc(toNum(r[c_year]));
      const polName = String(r[c_pol] ?? "").trim();
      const val = toNum(r[c_val]);

      if (!id || !Number.isFinite(year) || !polName || !Number.isFinite(val)) continue;

      const polNorm = stripAccentsLower(polName);
      const oldKey = id + "||" + polNorm;

      if (!sumByOldKeyYear.has(oldKey)) sumByOldKeyYear.set(oldKey, new Map());
      const mp = sumByOldKeyYear.get(oldKey);
      mp.set(year, (mp.get(year) || 0) + val);

      if (!oldNameByKey.has(oldKey)) oldNameByKey.set(oldKey, polName);

      totalByYear.set(year, (totalByYear.get(year) || 0) + val);
      yearsSet.add(year);
    }

    const years = Array.from(yearsSet).sort((a,b)=>a-b);

    // 3) Construye series por política moderna (suma de sus antiguas)
    const series = new Map();
    const labels_main = [];
    const labelKeySet = new Set();

    for (const m of mapping){
      const label = m.label;
      labels_main.push(label);
      labelKeySet.add(label);

      const xs = [];
      const ys = [];
      for (const y of years){
        const total = totalByYear.get(y);
        if (!Number.isFinite(total) || total === 0) continue;

        let sum = 0;
        let any = false;
        for (const it of m.olds){
          const mp = sumByOldKeyYear.get(it.key);
          if (!mp) continue;
          const v = mp.get(y);
          if (Number.isFinite(v)){
            sum += v;
            any = true;
          }
        }

        // Si esa política no tiene registro ese año, NO la dibujamos (evita caídas artificiales a 0)
        if (!any) continue;

        xs.push(y);
        ys.push((sum / total) * 100);
      }

      if (xs.length >= 2) series.set(label, { xs, ys });
    }

    // 4) (Opcional) X999 sin correspondencia (botón "Anteriores a 2004")
    const x999_labels = [];
    for (const [oldKey, mp] of sumByOldKeyYear.entries()){
      const id = oldKey.split("||")[0];
      if (id !== "X999") continue;
      if (usedOldKeys.has(oldKey)) continue;

      let label = oldNameByKey.get(oldKey) || oldKey;
      if (labelKeySet.has(label)) label = "X999 · " + label;

      const xs = [];
      const ys = [];
      for (const y of years){
        const total = totalByYear.get(y);
        if (!Number.isFinite(total) || total === 0) continue;

        const v = mp.get(y);
        if (!Number.isFinite(v)) continue;
        xs.push(y);
        ys.push((v / total) * 100);
      }

      if (xs.length >= 2){
        series.set(label, { xs, ys });
        x999_labels.push(label);
      }
    }
    x999_labels.sort((a,b)=>a.localeCompare(b, "es"));

    // 5) Duplicidades en el mapping (mismo oldKey asignado a múltiples modernas)
    const dup = [];
    for (const [k, arr] of oldKeyToModern.entries()){
      const uniq = Array.from(new Set(arr));
      if (uniq.length > 1){
        dup.push({ oldKey: k, modernIds: uniq });
      }
    }

    return { series, labels_main, x999_labels, years, mapping, dup };
  }

  
  // ---------- Preparación de series (vista completa / bruto) ----------
  function prepararSeriesPctBrutas(dataCsv){
    const colsData = dataCsv.headers;
    const rowsData = dataCsv.rows;

    const c_id   = pickCol(colsData, ["id_politica","id politica","id"]);
    const c_year = pickCol(colsData, ["año","ano","anio","year"]);
    const c_pol  = pickCol(colsData, ["politica","política"]);
    const c_val  = pickCol(colsData, ["presupuesto","valor","importe","amount"]);

    if (!c_id || !c_year || !c_pol || !c_val){
      throw new Error("pge_politicas_anio.csv: faltan columnas esperadas (id_politica / anio / politica / presupuesto).");
    }

    const sumByKeyYear = new Map(); // key -> Map(year->sum)
    const nameByKey = new Map();    // key -> politica (tal cual)
    const totalByYear = new Map();  // year -> total
    const yearsSet = new Set();

    for (const r of rowsData){
      const id = normId(r[c_id]);
      const year = Math.trunc(toNum(r[c_year]));
      const polName = String(r[c_pol] ?? "").trim();
      const val = toNum(r[c_val]);
      if (!id || !Number.isFinite(year) || !polName || !Number.isFinite(val)) continue;

      const polNorm = stripAccentsLower(polName);
      const key = id + "||" + polNorm;

      if (!sumByKeyYear.has(key)) sumByKeyYear.set(key, new Map());
      const mp = sumByKeyYear.get(key);
      mp.set(year, (mp.get(year) || 0) + val);

      if (!nameByKey.has(key)) nameByKey.set(key, polName);

      totalByYear.set(year, (totalByYear.get(year) || 0) + val);
      yearsSet.add(year);
    }

    const years = Array.from(yearsSet).sort((a,b)=>a-b);

    // Detecta colisiones de nombre (por si una misma "política" aparece con distintos IDs)
    const nameCounts = new Map();
    for (const [k, name] of nameByKey.entries()){
      const nm = String(name || "").trim();
      if (!nm) continue;
      nameCounts.set(nm, (nameCounts.get(nm) || 0) + 1);
    }

    const series = new Map();
    const labels = [];

    for (const [key, mp] of sumByKeyYear.entries()){
      const id = key.split("||")[0];
      const baseName = nameByKey.get(key) || key;

      // Si el nombre no es único, desambiguamos con el ID (solo en ese caso)
      const label = (nameCounts.get(baseName) > 1) ? (`${id} · ${baseName}`) : baseName;

      const xs = [];
      const ys = [];
      for (const y of years){
        const total = totalByYear.get(y);
        if (!Number.isFinite(total) || total === 0) continue;
        const v = mp.get(y);
        if (!Number.isFinite(v)) continue;
        xs.push(y);
        ys.push((v / total) * 100);
      }

      if (xs.length >= 2){
        series.set(label, { xs, ys });
        labels.push(label);
      }
    }

    labels.sort((a,b)=>String(a).localeCompare(String(b), "es"));
    return { series, labels, years };
  }

function renderMappingTable(mapping, dataCsvParsed){
    if (!mapBodyEl) return;
    mapBodyEl.innerHTML = "";

    // Para marcar si una "política antigua" existe o no en los datos anuales:
    const colsData = dataCsvParsed.headers;
    const rowsData = dataCsvParsed.rows;
    const c_id   = pickCol(colsData, ["id_politica","id politica","id"], false);
    const c_pol  = pickCol(colsData, ["politica","política"], false);

    const exists = new Set();
    if (c_id && c_pol){
      for (const r of rowsData){
        const id = normId(r[c_id]);
        const polName = String(r[c_pol] ?? "").trim();
        if (!id || !polName) continue;
        exists.add(id + "||" + stripAccentsLower(polName));
      }
    }

    for (const m of mapping){
      const tr = document.createElement("tr");

      const tdM = document.createElement("td");
      tdM.textContent = `${m.label}`;

      const tdO = document.createElement("td");
      if (!m.olds || !m.olds.length){
        tdO.textContent = "—";
      } else {
        for (const it of m.olds){
          const d = document.createElement("span");
          d.className = "mapOldItem";
          d.textContent = (it.name || it.pretty || "") + (exists.size ? (exists.has(it.key) ? "" : " (no encontrada)") : "");
          tdO.appendChild(d);
        }
      }

      tr.appendChild(tdM);
      tr.appendChild(tdO);
      mapBodyEl.appendChild(tr);
    }
  }

  const app = {
    mode: "compact",        // "compact" (agregado) | "raw" (bruto)
    datasets: { compact: null, raw: null },

    // Dataset activo (se rellena vía applyMode)
    labels: [],
    seriesByKey: new Map(),      // label -> {xs,ys}
    yearValueByKey: new Map(),   // label -> Map(year->pct)
    keyInfo: new Map(),          // label -> {label,color}

    xDomain: {min:1986, max:2023},
    mappingRows: [],             // mapping (solo vista compactada; tabla explicación)
    dup: [],
  };
  function buildSeriesList(){
    const out = [];
    for (const lab of app.labels){
      if (!app.seriesByKey.has(lab)) continue;
      const info = app.keyInfo.get(lab);
      out.push({
        key: lab,
        label: lab,
        color: info?.color || "rgba(176,176,176,.7)",
        badge: (app.mode === "raw") ? "bruto" : "",
        axis: "left",
      });
    }
    return out;
  }

  function getValueAtYear(key, year){
    const mp = app.yearValueByKey.get(key);
    if (!mp) return null;
    const v = mp.get(year);
    return Number.isFinite(v) ? v : null;
  }
  function getSeriesForPath(key){
    return app.seriesByKey.get(key) || null;
  }

  function tooltipSorter(a,b){
    const va = (a.v === null || !Number.isFinite(a.v)) ? -1 : a.v;
    const vb = (b.v === null || !Number.isFinite(b.v)) ? -1 : b.v;
    return vb - va;
  }

  async function loadPGE(){
    const [mapTxt, dataTxt] = await Promise.all([
      fetchText("pge_politicas.csv"),
      fetchText("pge_politicas_anio.csv"),
    ]);

    const mapCsv = parseCSV(mapTxt);
    const dataCsv = parseCSV(dataTxt);

    // A) Vista compactada (agregación por políticas modernas)
    const prepCompact = prepararSeriesPctModernas(mapCsv, dataCsv);
    if (!prepCompact || !prepCompact.series || !prepCompact.series.size){
      throw new Error("No se pudieron preparar las series de PGE (revisa pge_politicas.csv / pge_politicas_anio.csv).");
    }

    // B) Vista completa (bruto: todas las políticas de pge_politicas_anio.csv)
    const prepRaw = prepararSeriesPctBrutas(dataCsv);
    if (!prepRaw || !prepRaw.series || !prepRaw.series.size){
      throw new Error("No se pudieron preparar las series brutas de PGE (revisa pge_politicas_anio.csv).");
    }

    // Dominio X (unificado)
    const years = (prepCompact.years && prepCompact.years.length) ? prepCompact.years : (prepRaw.years || []);
    app.xDomain = { min: years[0] ?? 1986, max: years[years.length-1] ?? 2023 };

    // Años con PGE disponible por modo (sirve para decidir continuidad de líneas)
    app.pgeYearsByMode = {
      compact: new Set(prepCompact.years || []),
      raw: new Set(prepRaw.years || []),
    };


    // Guardar mapping (tabla explicación, siempre visible)
    app.mappingRows = prepCompact.mapping || [];
    app.dup = prepCompact.dup || [];

    // Helper: construir dataset (maps + colores) a partir de labels y series
    function buildDataset(labels, seriesMap, sat, val){
      const seriesByKey = new Map();
      const yearValueByKey = new Map();
      const keyInfo = new Map();

      const cols = colorList(labels.length, sat, val);
      const colorMap = new Map();
      labels.forEach((lab,i)=> colorMap.set(lab, cols[i] || "rgb(176,176,176)"));

      for (const lab of labels){
        const ser = seriesMap.get(lab);
        if (!ser) continue;

        seriesByKey.set(lab, ser);

        const mp = new Map();
        for (let i=0;i<ser.xs.length;i++) mp.set(ser.xs[i], ser.ys[i]);
        yearValueByKey.set(lab, mp);

        keyInfo.set(lab, { label: lab, color: colorMap.get(lab) });
      }

      return { labels, seriesByKey, yearValueByKey, keyInfo };
    }

    const dsCompact = buildDataset(prepCompact.labels_main || [], prepCompact.series, 0.9, 1.0);
    const dsRaw = buildDataset(prepRaw.labels || [], prepRaw.series, 0.55, 0.95);

    app.datasets.compact = dsCompact;
    app.datasets.raw = dsRaw;

    function updateModeButton(){
      if (!btnPre2004) return;
      const willGoRaw = (app.mode === "compact");
      btnPre2004.classList.toggle("on", app.mode === "raw");
      btnPre2004.textContent = willGoRaw ? "Vista completa" : "Vista compacta";
      btnPre2004.title = willGoRaw
        ? "Cambiar a vista completa: todas las políticas sin agregación (pge_politicas_anio.csv)"
        : "Cambiar a vista compactada: políticas modernas agregadas (pge_politicas.csv + pge_politicas_anio.csv)";
    }

    function applyMode(mode){
      const ds = app.datasets[mode];
      if (!ds) return;

      app.mode = mode;
      app.labels = ds.labels || [];
      app.seriesByKey = ds.seriesByKey;
      app.yearValueByKey = ds.yearValueByKey;
      app.keyInfo = ds.keyInfo;

      updateModeButton();
    }

    // Activa el modo por defecto (compact)
    applyMode(app.mode);

    // Render tabla de correspondencias (sin IDs visibles)
    renderMappingTable(app.mappingRows, dataCsv);

    if (unmappedNoteEl){
      const parts = [];
      parts.push(`Vista compactada: <b>${dsCompact.labels.length}</b> políticas modernas. Vista completa: <b>${dsRaw.labels.length}</b> políticas (sin agregación).`);
      parts.push(`Usa el botón <b>“${(app.mode === "compact") ? "Vista completa" : "Vista compacta"}”</b> para alternar.`);

      if (app.dup && app.dup.length){
        parts.push(`<span style="opacity:.95;">Nota técnica: se detectaron <b>${app.dup.length}</b> duplicidades en el mapping (una misma política antigua asignada a varias modernas). Si no era intencional, revisa <code>pge_politicas.csv</code>.</span>`);
      }

      unmappedNoteEl.innerHTML = parts.join(" ");
    }

    // Exponer applyMode / update UI para el handler del botón
    app.__applyMode = applyMode;
  }

  try{
    await loadPGE();
  } catch(e){
    if (errorEl){
      errorEl.style.display = "flex";
      errorEl.textContent = e.message || String(e);
    }
    window.__pge = { onShow: ()=>{} };
    return;
  }

  let controller = null;

  function rebuild(){
    const series = buildSeriesList();
    const yMax = computeYMax(series.map(s=>s.key));
    if (controller) controller.destroy();
    controller = makeChartController({
      svg, wrap, tooltipEl, errorEl,
      legendEl,
      controls,
      seriesList: series,
      getValueAtYear,
      getSeriesForPath,
      xDomain: app.xDomain,
      yDomain: { left: { min:0, max:yMax } },
      formatValue: (k,v)=>formatPct(v),
      extraBackground: drawPresBands,
      yTickBuilder,
      yLabelLeft: "Porcentaje del total (%)",
      yLabelRight: null,
      defaultOrderTooltip: null,
      topN: 15,
      valueSorter: (a,b)=>tooltipSorter(a,b),

      // Segmentación de líneas (PGE):
      // - Si un año no existe en el dataset (años sin PGE), NO cortamos: continuidad.
      // - Si el año sí existe (hubo PGE) pero una política no tiene registro, SÍ cortamos.
      segmentBreakRule: (key, prevYear, nextYear, gap, ser) => {
        const globalYears = app.pgeYearsByMode && app.pgeYearsByMode[app.mode];
        if (!globalYears || !ser || !ser.xs) return true;
        const yearSet = ser.__yearSet || (ser.__yearSet = new Set(ser.xs));
        for (let y = prevYear + 1; y <= nextYear - 1; y++){
          if (globalYears.has(y) && !yearSet.has(y)) return true;
        }
        return false;
      },

      // Sin corte artificial por 2004
      forceBreakAfterYears: null
    });
    window.__pge = { onShow: () => controller.onShow() };
  }

  if (btnPre2004){
    btnPre2004.addEventListener("click", () => {
      const next = (app.mode === "compact") ? "raw" : "compact";
      if (typeof app.__applyMode === "function") app.__applyMode(next);
      rebuild();
    });
  }

  rebuild();
})();


/* ===================== Vista 2: Gasto vs beneficio (PIB & Gasto) ===================== */
(async function(){
  const svg = document.getElementById("chartSvgGB");
  const wrap = document.getElementById("svgWrapGB");
  const tooltipEl = document.getElementById("tooltipGB");
  const errorEl = document.getElementById("errorBoxGB");
  const legendEl = document.getElementById("legendGB");
  const statsEl = document.getElementById("gbPresStats");

  const popBox = document.getElementById("gbPopBox");
  const popBody = document.getElementById("gbPopBody");

  const controls = {
    btnCrosshair: document.getElementById("btnCrosshairGB"),
  };

  const btnPolBands = document.getElementById("btnPolBandsGB");
  const btnPop = document.getElementById("btnPopGB");
  let showPresBands = true;
  let showPop = false;
  let popTableData = [];

  // Explicación (botón de pulso: hace scroll; no mantiene estado ON/OFF)
  const btnExplain = document.getElementById("btnExplainGB");
  const explainEl = document.getElementById("gbExplain");

  function pulseExplainGB(){
    if (!explainEl) return;

    // Si algún día la explicación se marca como colapsable, la abrimos aquí.
    if (explainEl.classList.contains("explainCollapsible")){
      explainEl.classList.add("open");
    }

    requestAnimationFrame(() => {
      const scroller = document.getElementById("viewGB") || explainEl.closest(".view");
      if (scroller && typeof scroller.scrollTo === "function"){
        const sr = scroller.getBoundingClientRect();
        const tr = explainEl.getBoundingClientRect();
        const top = (tr.top - sr.top) + (scroller.scrollTop || 0) - 8;
        scroller.scrollTo({ top: Math.max(0, top), behavior: "smooth" });
      } else {
        explainEl.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    });
  }

  if (btnExplain){
    btnExplain.classList.remove("on");
    btnExplain.textContent = "Explicación";
    btnExplain.addEventListener("click", pulseExplainGB);
  }

  function fmtPop(v){
    return Number.isFinite(v) ? Math.round(v).toLocaleString("es-ES") : "—";
  }

  function renderPopTable(){
    if (!popBody) return;
    popBody.innerHTML = "";
    for (const r of popTableData){
      const tr = document.createElement("tr");
      const tdY = document.createElement("td");
      tdY.textContent = String(r.year);
      const tdP = document.createElement("td");
      tdP.textContent = fmtPop(r.pop);
      tr.appendChild(tdY);
      tr.appendChild(tdP);
      popBody.appendChild(tr);
    }
  }


  function updatePopUI(){
    if (btnPop){
      btnPop.classList.toggle("on", showPop);
      btnPop.textContent = "Población: " + (showPop ? "ON" : "OFF");
    }
    // La tabla antigua ya no se usa: ahora dibujamos flechas dentro del gráfico
    if (popBox){
      popBox.style.display = "none";
    }
  }


  const BASE_SERIES = [
    { key:"pib_total",   label:"PIB total",                 color:"#00E5FF", axis:"left",  unit:"B€" },
    { key:"gasto_total", label:"Gasto público total",       color:"#FF6A00", axis:"left",  unit:"B€" },
    { key:"pib_pc",      label:"PIB per cápita",            color:"#79FF6B", axis:"right", unit:"k€" },
    { key:"gasto_pc",    label:"Gasto público per cápita",  color:"#FF3D8D", axis:"right", unit:"k€" },
  ];
  const POP_SERIES = { key:"poblacion_total", label:"Población total", color:"rgba(176,176,176,.9)", axis:"right", unit:"M" };

  const app = {
    xDomain: { min: 1986, max: 2023 },
    series: new Map(),      // key -> {xs,ys}
    yearVal: new Map(),     // key -> Map(year->v)
  };


  function drawPopArrowsInPlot(g, geom){
    if (!showPop) return;

    const mp = app.yearVal.get("poblacion_total");
    if (!mp) return;

    const items = [];
    let maxAbs = 0;

    for (let y = app.xDomain.min + 1; y <= app.xDomain.max; y++){
      const v0 = mp.get(y - 1);
      const v1 = mp.get(y);
      if (!Number.isFinite(v0) || !Number.isFinite(v1) || v0 === 0) continue;

      const pct = (v1 / v0 - 1) * 100;
      const abs = Math.abs(pct);
      if (abs > maxAbs) maxAbs = abs;
      items.push({ year: y, pct });
    }

    if (!items.length) return;

    g.setAttribute("style", "pointer-events:none;");

    const plotRect = geom.plotRect;
    const xScale = geom.xScale;

    const minLen = 6;
    const maxLen = 18;
    const minHeadW = 5;
    const maxHeadW = 10;

    // Mantiene las flechas dentro del área de dibujo, cerca del borde superior del gráfico
    const yAnchor = plotRect.y + 6 + maxLen;

    for (const it of items){
      const x = xScale(it.year);
      if (!Number.isFinite(x)) continue;
      if (x < plotRect.x - 2 || x > plotRect.x + plotRect.w + 2) continue;

      const scale = (maxAbs > 0) ? (Math.abs(it.pct) / maxAbs) : 0;
      const len = minLen + scale * (maxLen - minLen);
      const headW = minHeadW + scale * (maxHeadW - minHeadW);
      const headH = Math.max(4, headW * 0.75);

      const up = it.pct >= 0;
      const col = up ? "rgba(0, 200, 90, .95)" : "rgba(230, 60, 60, .95)";

      const tipY = up ? (yAnchor - len) : (yAnchor + len);
      const stemStart = up ? (yAnchor + len * 0.55) : (yAnchor - len * 0.55);
      const stemEnd = up ? (tipY + headH) : (tipY - headH);

      // Tallo
      g.appendChild(createSvgEl("line", {
        x1: x, y1: stemStart, x2: x, y2: stemEnd,
        stroke: col,
        "stroke-width": (1.25 + scale * 1.25).toFixed(2),
        "stroke-linecap": "round",
        opacity: 0.95,
        "vector-effect": "non-scaling-stroke"
      }));

      // Punta
      const p1 = `${x},${tipY}`;
      const p2 = `${x - headW/2},${up ? (tipY + headH) : (tipY - headH)}`;
      const p3 = `${x + headW/2},${up ? (tipY + headH) : (tipY - headH)}`;
      g.appendChild(createSvgEl("polygon", {
        points: `${p1} ${p2} ${p3}`,
        fill: col,
        stroke: "rgba(0,0,0,.35)",
        "stroke-width": 0.6,
        opacity: 0.98,
        "vector-effect": "non-scaling-stroke"
      }));
    }
  }


  function getSeriesDefs(){
    return BASE_SERIES.slice();
  }

  function formatVal(key, v){
    if (!Number.isFinite(v)) return "—";
    const s = getSeriesDefs().find(x => x.key === key) || BASE_SERIES.find(x=>x.key===key) || POP_SERIES;
    if (s.unit === "B€") return v.toFixed(1) + " B€";
    if (s.unit === "k€") return v.toFixed(1) + " k€";
    if (s.unit === "M")  return v.toFixed(2) + " M";
    return v.toFixed(1);
  }

  function getSeriesForPath(key){ return app.series.get(key) || null; }
  function getValueAtYear(key, year){
    const mp = app.yearVal.get(key);
    if (!mp) return null;
    const v = mp.get(year);
    return Number.isFinite(v) ? v : null;
  }

  function extraBackground(gBg, xScale, plotRect){
    if (!showPresBands) return;
    for (const p of PRES_BANDS){
      const x0 = Math.max(app.xDomain.min, p.start);
      const x1 = Math.min(app.xDomain.max, p.end ?? app.xDomain.max);
      if (x1 <= x0) continue;
      const x = xScale(x0);
      const w = xScale(x1) - xScale(x0);
      gBg.appendChild(createSvgEl("rect", {
        x, y: plotRect.y, width: w, height: plotRect.h,
        fill: p.color, opacity: 0.18
      }));
    }
  }

  async function loadGB(){
    const txt = await fetchText("indicadores_estado_a_1986.csv");
    const csv = parseCSV(txt);
    const h = csv.headers;

    const cYear = pickCol(h, ["anio","año","year"]);
    const cPop  = pickCol(h, ["poblacion_total","población_total","poblacion"]);
    const cPIB  = pickCol(h, ["pib_total_eur_a_1986"]);
    const cGTO  = pickCol(h, ["gasto_publico_eur_a_1986"]);
    const cPIBPC= pickCol(h, ["pib_per_capita_eur_a_1986"]);
    const cGTOPC= pickCol(h, ["gasto_publico_per_capita_eur_a_1986"]);

    if (!cYear || !cPIB || !cGTO || !cPIBPC || !cGTOPC || !cPop){
      throw new Error("indicadores_estado_a_1986.csv: faltan columnas requeridas (anio, poblacion_total, pib/gasto a 1986, per cápita).");
    }

    const rows = [];
    for (const r of csv.rows){
      const year = Math.round(toNum(r[cYear]));
      if (!Number.isFinite(year)) continue;
      rows.push({
        year,
        pop: toNum(r[cPop]),
        pib: toNum(r[cPIB]),
        gto: toNum(r[cGTO]),
        pibpc: toNum(r[cPIBPC]),
        gtopc: toNum(r[cGTOPC]),
      });
    }
    if (!rows.length) throw new Error("indicadores_estado_a_1986.csv no tiene filas válidas.");
    // Población (para tabla inferior)
    popTableData = rows
      .filter(r => Number.isFinite(r.year) && Number.isFinite(r.pop))
      .sort((a,b)=>a.year-b.year)
      .map(r => ({ year: r.year, pop: r.pop }));


    const minY = rows.reduce((m,r)=>Math.min(m,r.year), Infinity);
    const maxY = rows.reduce((m,r)=>Math.max(m,r.year), -Infinity);
    app.xDomain = { min: Math.max(1986, minY), max: Math.min(2023, maxY) };

    const baseMaps = new Map([
      ["pib_total", new Map()],
      ["gasto_total", new Map()],
      ["pib_pc", new Map()],
      ["gasto_pc", new Map()],
      ["poblacion_total", new Map()],
    ]);

    for (const r of rows){
      if (r.year < app.xDomain.min || r.year > app.xDomain.max) continue;
      baseMaps.get("pib_total").set(r.year, Number.isFinite(r.pib) ? r.pib/1e9 : NaN);
      baseMaps.get("gasto_total").set(r.year, Number.isFinite(r.gto) ? r.gto/1e9 : NaN);
      baseMaps.get("pib_pc").set(r.year, Number.isFinite(r.pibpc) ? r.pibpc/1000 : NaN);
      baseMaps.get("gasto_pc").set(r.year, Number.isFinite(r.gtopc) ? r.gtopc/1000 : NaN);
      baseMaps.get("poblacion_total").set(r.year, Number.isFinite(r.pop) ? r.pop/1e6 : NaN);
    }

    const years = [];
    for (let y=app.xDomain.min; y<=app.xDomain.max; y++) years.push(y);

    app.series.clear();
    app.yearVal.clear();

    for (const [k, ymap] of baseMaps.entries()){
      const out = new Map();
      let last = null;
      for (const y of years){
        const v = ymap.get(y);
        if (v === undefined || v === null || !Number.isFinite(v)){
          out.set(y, (last === null) ? NaN : last);
        } else {
          out.set(y, v);
          last = v;
        }
      }
      app.yearVal.set(k, out);

      const xs = [];
      const ys = [];
      for (const y of years){
        const vv = out.get(y);
        if (Number.isFinite(vv)){
          xs.push(y);
          ys.push(vv);
        }
      }
      app.series.set(k, { xs, ys });
    }
  }

  function pctChange(v0, v1){
    if (!Number.isFinite(v0) || !Number.isFinite(v1) || v0 === 0) return null;
    return (v1 / v0 - 1) * 100;
  }
  function fmtPctSigned(p){
    if (p === null || !Number.isFinite(p)) return "—";
    const s = (p >= 0) ? "+" : "";
    return s + p.toFixed(1) + "%";
  }
  function getNearestValue(key, year){
    const ser = app.series.get(key);
    if (!ser || !ser.xs || !ser.xs.length) return null;
    let bestYear = ser.xs[0];
    let bestDist = Math.abs(bestYear - year);
    for (const y of ser.xs){
      const d = Math.abs(y - year);
      if (d < bestDist){
        bestDist = d;
        bestYear = y;
      }
    }
    const mp = app.yearVal.get(key);
    const v = mp ? mp.get(bestYear) : null;
    return Number.isFinite(v) ? v : null;
  }

  function buildTicks(maxV){
    const step = niceStepY(maxV);
    const top = Math.ceil(maxV/step)*step;
    const out = [];
    for (let v=0; v<=top+1e-9; v+=step) out.push(Number(v.toFixed(10)));
    return out;
  }

  function renderPresStats(controller){
    if (!statsEl) return;
    statsEl.innerHTML = "";

    const seriesDefs = getSeriesDefs();

    // 1) Totales 1986–2023
    const top = document.createElement("div");
    top.className = "psTop";

    for (const s of seriesDefs){
      const v0 = getNearestValue(s.key, app.xDomain.min);
      const v1 = getNearestValue(s.key, app.xDomain.max);
      const g = pctChange(v0, v1);

      const row = document.createElement("div");
      row.className = "psItem";

      const sw = document.createElement("div");
      sw.className = "psSw";
      sw.style.background = s.color;

      const lab = document.createElement("div");
      lab.className = "psLabel";
      lab.textContent = `${s.label} (${fmtPctSigned(g)})`;

      row.appendChild(sw);
      row.appendChild(lab);
      top.appendChild(row);
    }
    statsEl.appendChild(top);

    // 2) Por presidencia (formato vertical: título + líneas)
    const blocks = document.createElement("div");
    blocks.className = "psBlocks";

    const detail = [
      { label:"PIB",    key:"pib_total",   color:"#00E5FF" },
      { label:"PIB pc", key:"pib_pc",      color:"#79FF6B" },
      { label:"Gto",    key:"gasto_total", color:"#FF6A00" },
      { label:"Gto pc", key:"gasto_pc",    color:"#FF3D8D" },
    ];
    const allDetailKeys = detail.map(d=>d.key);

    for (const p of PRES_PERIODS){
      const blk = document.createElement("div");
      blk.className = "psMandate";

      const title = document.createElement("div");
      title.className = "psMandateTitle";
      title.style.cursor = "pointer";

      // Nombre (con salto para Zapatero como antes) + años pegados (como pides)
      const nm = (p.name === "José Luis Rodríguez Zapatero")
        ? "José Luis Rodríguez\nZapatero"
        : p.name;

      title.innerHTML = (nm + String(p.start) + "–" + String(p.end))
        .replace(/\n/g, "<br>")
        .replace(/(\d{4}–\d{4})$/, '<span class="yrs">$1</span>');

      title.addEventListener("mouseenter", () => controller.setHighlight(p.start, p.end, allDetailKeys));
      title.addEventListener("mouseleave", () => controller.clearHighlight());

      blk.appendChild(title);

      for (const d of detail){
        const a = getNearestValue(d.key, p.start);
        const b = getNearestValue(d.key, p.end);
        const g = pctChange(a, b);

        const ln = document.createElement("div");
        ln.className = "psMandateLine";
        ln.style.cursor = "pointer";

        const k = document.createElement("div");
        k.className = "k";
        k.textContent = d.label + ":";

        const v = document.createElement("div");
        v.className = "v";
        v.textContent = fmtPctSigned(g);
        v.style.color = d.color;

        ln.appendChild(k);
        ln.appendChild(v);

        ln.addEventListener("mouseenter", () => controller.setHighlight(p.start, p.end, [d.key]));
        ln.addEventListener("mouseleave", () => controller.clearHighlight());

        blk.appendChild(ln);
      }

      blocks.appendChild(blk);
    }

    statsEl.appendChild(blocks);
  }

  let controller = null;

  function rebuild(){
    const seriesDefs = getSeriesDefs();
    // Marcadores de color en las etiquetas de los ejes (GB)
    const yLabelLeftMarkers = seriesDefs.filter(s=>s.axis==="left").map(s=>s.color);
    const yLabelRightMarkers = seriesDefs.filter(s=>s.axis==="right").map(s=>s.color);


    // y ranges
    const leftKeys = seriesDefs.filter(s=>s.axis==="left").map(s=>s.key);
    const rightKeys= seriesDefs.filter(s=>s.axis==="right").map(s=>s.key);

    let yLmax = 1, yRmax = 1;
    for (const k of leftKeys){
      const ser = app.series.get(k);
      if (!ser) continue;
      for (const v of ser.ys) if (Number.isFinite(v)) yLmax = Math.max(yLmax, v);
    }
    for (const k of rightKeys){
      const ser = app.series.get(k);
      if (!ser) continue;
      for (const v of ser.ys) if (Number.isFinite(v)) yRmax = Math.max(yRmax, v);
    }
    yLmax *= 1.06;
    yRmax *= 1.06;

    const rightTicks = buildTicks(yRmax);

    if (controller) controller.destroy();

    controller = makeChartController({
      svg, wrap, tooltipEl, errorEl,
      legendEl,
      controls,
      seriesList: seriesDefs.map(s => ({ key:s.key, label:s.label, color:s.color, axis:s.axis })),
      getValueAtYear,
      getSeriesForPath,
      xDomain: app.xDomain,
      yDomain: { left: { min: 0, max: yLmax } },
      formatValue: (k,v)=>formatVal(k,v),
      extraBackground,
      extraAnnotations: (gAnn, geom) => drawPopArrowsInPlot(gAnn, geom),
      rightAxis: { ticks: rightTicks, formatTick: (v)=>String(v) },
      yLabelLeft: "Miles de millones de € (1986)",
      yLabelRight: "Miles de € por persona (1986)",
      yLabelLeftMarkers,
      yLabelRightMarkers,
      defaultOrderTooltip: seriesDefs.map(s=>s.key),
      topN: 0
    });

    renderPresStats(controller);
    window.__gb = { onShow: () => controller.onShow() };
  }

  // init buttons
  if (btnPolBands){
    btnPolBands.classList.toggle("on", showPresBands);
    btnPolBands.textContent = "Políticos: " + (showPresBands ? "ON" : "OFF");
    btnPolBands.addEventListener("click", () => {
      showPresBands = !showPresBands;
      btnPolBands.classList.toggle("on", showPresBands);
      btnPolBands.textContent = "Políticos: " + (showPresBands ? "ON" : "OFF");
      if (controller) controller.onShow();
    });
  }
  if (btnPop){
    updatePopUI();
    btnPop.addEventListener("click", () => {
      showPop = !showPop;
      updatePopUI();
      if (controller) controller.onShow();
    });
  }
  // Explicación: botón de pulso (sin estado) ya configurado arriba.
try{
    await loadGB();
    updatePopUI();
  } catch(e){
    errorEl.style.display = "flex";
    errorEl.textContent = e.message || String(e);
    window.__gb = { onShow: ()=>{} };
    return;
  }

  rebuild();
})();


/* ===================== Vista 3: Presión fiscal ===================== */
(async function(){
  const svg = document.getElementById("chartSvgPA");
  const wrap = document.getElementById("svgWrapPA");
  const tooltipEl = document.getElementById("tooltipPA");
  const errorEl = document.getElementById("errorBoxPA");
  const legendEl = document.getElementById("legendPA");

  const controls = { };
  const btnPolBands = document.getElementById("btnPolBandsPA");
  let showPresBands = true;
  if (btnPolBands){
    btnPolBands.classList.toggle("on", showPresBands);
    btnPolBands.textContent = "Políticos: " + (showPresBands ? "ON" : "OFF");
  }

  // Explicación (botón de pulso: hace scroll; no mantiene estado ON/OFF)
  const btnExplain = document.getElementById("btnExplainPA");
  const explainEl = document.getElementById("paExplain");

  function pulseExplainPA(){
    if (!explainEl) return;

    if (explainEl.classList.contains("explainCollapsible")){
      explainEl.classList.add("open");
    }

    requestAnimationFrame(() => {
      const scroller = document.getElementById("viewPA") || explainEl.closest(".view");
      if (scroller && typeof scroller.scrollTo === "function"){
        const sr = scroller.getBoundingClientRect();
        const tr = explainEl.getBoundingClientRect();
        const top = (tr.top - sr.top) + (scroller.scrollTop || 0) - 8;
        scroller.scrollTo({ top: Math.max(0, top), behavior: "smooth" });
      } else {
        explainEl.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    });
  }

  if (btnExplain){
    btnExplain.classList.remove("on");
    btnExplain.textContent = "Explicación";
    btnExplain.addEventListener("click", pulseExplainPA);
  }

  const app = {
    xDomain: { min: 1986, max: 2023 },
    series: new Map(),
    yearVal: new Map(),
  };

  const seriesDefs = [
    { key:"pf", col:"presion_fiscal_real_1986_pct", label:"Presión fiscal", color:"#FF3D8D", axis:"left" },
    { key:"gp", col:"gasto_publico_per_capita_pct_1986", label:"Presión de gasto público", color:"#34D399", axis:"left" },
    { key:"ef", col:"esfuerzo_fiscal_simple", label:"Esfuerzo fiscal simple", color:"#3DA6FF", axis:"right" },
  ];

  function drawPresBands(gBg, xScale, plotRect){
    if (!showPresBands) return;
    for (const p of PRES_BANDS){
      const x0 = Math.max(app.xDomain.min, p.start);
      const x1 = Math.min(app.xDomain.max, (p.end ?? app.xDomain.max));
      if (x1 <= x0) continue;
      const x = xScale(x0);
      const w = xScale(x1) - xScale(x0);
      gBg.appendChild(createSvgEl("rect", {
        x, y: plotRect.y, width: w, height: plotRect.h,
        fill: p.color, opacity: 0.18
      }));
    }
  }

  function getSeriesForPath(key){ return app.series.get(key) || null; }
  function getValueAtYear(key, year){
    const mp = app.yearVal.get(key);
    if (!mp) return null;
    const v = mp.get(year);
    return Number.isFinite(v) ? v : null;
  }

  function formatValue(key, v){
    if (!Number.isFinite(v)) return "—";
    if (key === "ef") return v.toFixed(2); // índice
    return v.toFixed(1) + "%";
  }

  function niceTicks(minV, maxV){
    // ticks inclusivos (pueden empezar > 0)
    const span = Math.max(1e-9, maxV - minV);
    const step = niceStepY(span);
    const a = Math.floor(minV/step)*step;
    const b = Math.ceil(maxV/step)*step;
    const out = [];
    for (let x=a; x<=b+1e-9; x+=step){
      out.push(Math.round(x*1000)/1000);
    }
    return out;
  }

  async function loadPA(){
    const txt = await fetchText("indicadores_estado_a_1986.csv");
    const csv = parseCSV(txt);
    const h = csv.headers;

    const cYear = pickCol(h, ["anio","año","year"]);
    if (!cYear){
      throw new Error("indicadores_estado_a_1986.csv: falta la columna de año (anio/año/year).");
    }

    const cols = new Map();
    for (const sd of seriesDefs){
      const c = pickCol(h, [sd.col]);
      if (!c){
        throw new Error(`indicadores_estado_a_1986.csv: falta la columna ${sd.col}.`);
      }
      cols.set(sd.key, c);
    }

    const mpByKey = new Map(seriesDefs.map(sd => [sd.key, new Map()]));
    const yearsOk = [];

    for (const r of csv.rows){
      const year = Math.round(toNum(r[cYear]));
      if (!Number.isFinite(year)) continue;
      if (year < 1986 || year > 2023) continue;

      let any = false;
      for (const sd of seriesDefs){
        const v = toNum(r[cols.get(sd.key)]);
        if (Number.isFinite(v)){
          mpByKey.get(sd.key).set(year, v);
          any = true;
        }
      }
      if (any) yearsOk.push(year);
    }

    if (!yearsOk.length){
      throw new Error("No hay datos válidos en el rango 1986–2023 para las series seleccionadas.");
    }

    // Dominio X (fijo 1986–2023, pero validamos que haya algo dentro)
    app.xDomain = { min: 1986, max: 2023 };

    // Construir series (xs/ys) por clave
    for (const sd of seriesDefs){
      const mp = mpByKey.get(sd.key);
      app.yearVal.set(sd.key, mp);

      const xs = Array.from(mp.keys()).sort((a,b)=>a-b);
      const ys = xs.map(x => mp.get(x));
      app.series.set(sd.key, { xs, ys });
    }
  }

  try{
    await loadPA();
  } catch(e){
    if (errorEl){
      errorEl.style.display = "flex";
      errorEl.textContent = e.message || String(e);
    }
    window.__pa = { onShow: ()=>{} };
    return;
  }

  // Dominios Y
  const leftKeys = seriesDefs.filter(s=>s.axis==="left").map(s=>s.key);
  const rightKeys = seriesDefs.filter(s=>s.axis==="right").map(s=>s.key);

  let leftMax = 0;
  for (const k of leftKeys){
    const ser = app.series.get(k);
    if (!ser) continue;
    for (const v of ser.ys){
      if (Number.isFinite(v)) leftMax = Math.max(leftMax, v);
    }
  }
  leftMax = Math.max(1, leftMax) * 1.05;

  // right axis ticks (para esfuerzo fiscal)
  let rightMin = Infinity, rightMax = -Infinity;
  for (const k of rightKeys){
    const ser = app.series.get(k);
    if (!ser) continue;
    for (const v of ser.ys){
      if (Number.isFinite(v)){
        rightMin = Math.min(rightMin, v);
        rightMax = Math.max(rightMax, v);
      }
    }
  }
  const rightTicks = Number.isFinite(rightMin) && Number.isFinite(rightMax)
    ? niceTicks(rightMin, rightMax)
    : null;

  const yLabelLeftMarkers = seriesDefs.filter(s=>s.axis==="left").map(s=>s.color);
  const yLabelRightMarkers = seriesDefs.filter(s=>s.axis==="right").map(s=>s.color);


  const controller = makeChartController({
    svg, wrap, tooltipEl, errorEl,
    legendEl,
    controls,
    seriesList: seriesDefs.map(s => ({ key:s.key, label:s.label, color:s.color, axis:s.axis })),
    getValueAtYear,
    getSeriesForPath,
    xDomain: app.xDomain,
    yDomain: { left: { min: 0, max: leftMax } },
    rightAxis: rightTicks ? { ticks: rightTicks, formatTick: (v)=>String(v) } : null,
    formatValue,
    extraBackground: drawPresBands,
    alwaysTooltip: true,
    yLabelLeft: "Porcentaje (%)",
    yLabelRight: rightTicks ? "Esfuerzo fiscal (índice)" : null,
    yLabelLeftMarkers,
    yLabelRightMarkers,
    defaultOrderTooltip: ["pf","gp","ef"],
    topN: 0
  });

  if (btnPolBands){
    btnPolBands.addEventListener("click", () => {
      showPresBands = !showPresBands;
      btnPolBands.classList.toggle("on", showPresBands);
      btnPolBands.textContent = "Políticos: " + (showPresBands ? "ON" : "OFF");
      controller.onShow();
    });
  }

  window.__pa = { onShow: () => controller.onShow() };
  if (window.__activeViewKey === "pa") requestAnimationFrame(() => controller.onShow());
})();
</script>
</body>
</html>
