<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pensiones — Simulador (Móvil)</title>

  <style>
    :root{
      --fontScale: 1.12;
      --axisLabelFontScale: 1.05;

      /* ===== Tipografías por gráfica (multiplicador interno de SVG) =====
         - Evolución en el tiempo:   --chartFontScaleTime
         - C–P y equilibrio:        --chartFontScaleCP
         - Pirámide:                --chartFontScalePyr
      */
      --chartFontScaleTime: 2.0;
      --chartFontScaleCP:   2.0;
      --chartFontScalePyr:  1.5;

      /* ===== Distancia horizontal de la etiqueta del eje Y (unidades base del SVG; se escala con su()) =====
         Valores más pequeños acercan el texto al eje (menos desplazamiento hacia la izquierda).
      */
      --axisLabelGapTime:    55;
      --axisLabelGapCP:      40;

--bg:#252525;
      --primary:#FEF702;
      --text:#B0B0B0;
      --grid:#4A4A4A;

      --workers:#36C3FF;
      --retired:#FF6A00;
      --minors:#7f7f7f;
      --noncot:#1f6d86;

      --stroke:#3a3a3a;

      --fontTitle: "Futura","Trebuchet MS",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      --fontText:  Arial,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;

      --radius:14px;
      --shadow: 0 10px 30px rgba(0,0,0,.25);

      --workersRowLeftGap: 10px;
    }

    @media (max-width: 420px){
      :root{
        --fontScale: 1.06;
        --axisLabelFontScale: 1.00;

        /* Si quieres tipografías algo más pequeñas en pantallas muy estrechas, ajusta aquí:
        --chartFontScaleTime: 2.0;
        --chartFontScaleCP: 2.0;
        --chartFontScalePyr: 2.0;
        */
      }
    }

    *{box-sizing:border-box}
    body{ margin:0; background:var(--bg); color:var(--text); font-family:var(--fontText); }

    header{
      padding:14px 12px 8px 12px;
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      justify-content:flex-start;
      gap:10px;
    }
    .h-title{ line-height:1.05; width:100%; }
    .h-title h1{
      margin:0;
      font-family:var(--fontTitle);
      color:var(--primary);
      font-size: calc(22px * var(--fontScale));
      letter-spacing:.3px;
    }
    .h-title p{
      margin:6px 0 0 0;
      font-size: calc(13px * var(--fontScale));
      opacity:.9;
      max-width:110ch;
    }
    .h-meta{
      width:100%;
      font-size: calc(12px * var(--fontScale));
      opacity:.85;
      display:flex;
      justify-content:flex-end;
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border:1px solid var(--stroke);
      border-radius:999px;
      background:rgba(255,255,255,.03);
    }
    .dot{
      width:8px; height:8px; border-radius:50%;
      background:var(--primary);
      box-shadow:0 0 0 3px rgba(254,247,2,.15);
    }
    a.back{
      color:var(--text);
      text-decoration:none;
      border-bottom:1px solid rgba(255,255,255,.18);
      padding-bottom:1px;
    }
    a.back:hover{ border-bottom-color: rgba(254,247,2,.35); color:#fff; }

    main{
      min-height: calc(100vh - 70px);
      padding:10px 10px 16px 10px;
    }

    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .ph{
      padding:10px 10px 10px 10px;
      border-bottom:1px solid var(--stroke);
      background:rgba(255,255,255,.02);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .ttl{
      font-family:var(--fontTitle);
      color:var(--primary);
      font-size: calc(13px * var(--fontScale));
      letter-spacing:.35px;
      text-transform:uppercase;
      white-space:nowrap;
    }
    .sub{
      font-size: calc(12px * var(--fontScale));
      opacity:.85;
      text-align:right;
      max-width:62ch;
      flex: 1 1 auto;
    }

    .oecdbar{
      padding:10px 10px;
      border-bottom:1px solid var(--stroke);
      background:rgba(0,0,0,.08);
      display:flex;
      align-items:stretch;
      gap:10px;
      flex-wrap:wrap;
    }
    .oecd-left{
      display:flex;
      align-items:center;
      gap:10px;
      flex:1 1 100%;
      min-width:240px;
    }
    .oecd-label{
      font-family:var(--fontTitle);
      color:var(--primary);
      font-size: calc(12px * var(--fontScale));
      letter-spacing:.35px;
      text-transform:uppercase;
      white-space:nowrap;
      opacity:.95;
    }
    .oecd-select{
      flex:1 1 auto;
      min-width:200px;
      appearance:none;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.14);
      color:var(--text);
      border-radius:12px;
      padding:12px 12px;
      font-size: calc(13px * var(--fontScale));
      outline:none;
    }
    .oecd-select:focus{
      border-color: rgba(254,247,2,.35);
      box-shadow: 0 0 0 3px rgba(254,247,2,.10);
    }
    .oecd-btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      color:var(--text);
      border-radius:12px;
      padding:11px 12px;
      font-size: calc(12px * var(--fontScale));
      cursor:pointer;
      white-space:nowrap;
      flex: 1 1 calc(50% - 10px);
    }
    .oecd-btn:hover{
      border-color: rgba(254,247,2,.25);
      background:rgba(255,255,255,.04);
      color:#fff;
    }
    .oecd-btn.primary{
      background: var(--primary);
      color:#111;
      border-color: rgba(0,0,0,.35);
    }
    .oecd-btn.primary:hover{ filter: brightness(0.95); }

    .oecd-toggle{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.14);
      font-size: calc(12px * var(--fontScale));
      opacity:.95;
      user-select:none;
      white-space:nowrap;
      flex: 1 1 100%;
    }
    .oecd-toggle input{ accent-color: var(--primary); }
    .oecd-info{
      flex: 1 1 100%;
      min-width: 240px;
      font-size: calc(11px * var(--fontScale));
      opacity:.78;
      line-height:1.25;
    }
    .oecd-hint{
      padding:0 10px 10px 10px;
      font-size: calc(11px * var(--fontScale));
      opacity:.72;
      line-height:1.35;
    }

    .oecd-details{ position:relative; flex: 1 1 100%; }
    .oecd-details > summary{ list-style:none; }
    .oecd-details > summary::-webkit-details-marker{ display:none; }
    .oecd-details-panel{
      margin-top:8px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.14);
      border-radius:12px;
      font-size: calc(11px * var(--fontScale));
      opacity:.78;
      line-height:1.35;
      max-width: 680px;
    }

        /* Indicador visual de desplegables (más vistoso) */
    .oecd-details > summary.oecd-btn{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .oecd-details > summary.oecd-btn::after{
      content:"▼";
      display:flex;
      align-items:center;
      justify-content:center;
      width:36px;
      height:36px;
      border-radius:12px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.14);
      color: var(--text);
      font-size: 18px;
      box-shadow: 0 2px 10px rgba(0,0,0,.22);
      flex:0 0 auto;
      transition: transform .18s ease, background .18s ease, border-color .18s ease, color .18s ease;
    }
    .oecd-details > summary.oecd-btn:hover::after{
      background: rgba(255,255,255,.09);
      border-color: rgba(255,255,255,.22);
      color:#fff;
    }

.oecd-details[open] > summary.oecd-btn::after{
      transform: rotate(180deg);
      }

    .caption-details > summary.caption-toggle{
      display:inline-flex;
      align-items:center;
      gap:10px;
    }
    .caption-details > summary.caption-toggle::after{
      content:"▼";
      display:flex;
      align-items:center;
      justify-content:center;
      width:32px;
      height:32px;
      border-radius:10px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.14);
      color: var(--text);
      font-size: 16px;
      box-shadow: 0 2px 10px rgba(0,0,0,.22);
      flex:0 0 auto;
      transition: transform .18s ease, background .18s ease, border-color .18s ease, color .18s ease;
    }
    .caption-details > summary.caption-toggle:hover::after{
      background: rgba(255,255,255,.09);
      border-color: rgba(255,255,255,.22);
      color:#fff;
    }

.caption-details[open] > summary.caption-toggle::after{
      transform: rotate(180deg);
      }

    /* Más altura para la gráfica temporal (para evitar solapes de leyenda/etiqueta) */
    #timeSvg{ aspect-ratio: 1000 / 1050; }


    /* Ajuste de proporción para que "C–P y equilibrio" NO se vea achatada */
    #cpSvg{ aspect-ratio: 1000 / 1000; }
#oecdInfo{ display:none !important; }

    .oecd-nav{
      display:flex;
      gap:10px;
      flex: 1 1 100%;
    }

    .chart-area{
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      height:100%;
    }

    /* MÓVIL: 1 columna SIEMPRE */
    .charts-row{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      align-items:start;
    }

    .chart-card{
      border:1px solid rgba(255,255,255,.06);
      border-radius:12px;
      background:rgba(0,0,0,.08);
      overflow:hidden;
    }

    .chart-card .ch{
      padding:10px 10px 8px 10px;
      border-bottom:1px solid rgba(255,255,255,.06);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }

    .chart-card .ch .cttl{
      font-family:var(--fontTitle);
      color:var(--primary);
      font-size: calc(14px * var(--fontScale));
      letter-spacing:.35px;
      text-transform:uppercase;
    }
    .chart-card .ch .csub{
      font-size: calc(12px * var(--fontScale));
      opacity:.85;
      text-align:right;
      font-variant-numeric: tabular-nums;
      line-height:1.2;
      flex:1 1 auto;
      min-width: 140px;
    }

    .chart-card .ch.cp-head{
      display:block;
      align-items:unset;
      justify-content:unset;
    }

    .cp-head-row{
      display:grid;
      grid-template-columns: 1fr;
      gap:8px;
      align-items:center;
    }

    .cp-mid{
      display:flex;
      align-items:center;
      justify-content:flex-start;
      gap:8px;
      flex-wrap:wrap;
      min-width:0;
    }
    .cp-right{
      text-align:left;
      white-space:normal;
      opacity:.85;
      font-variant-numeric: tabular-nums;
      line-height:1.2;
      font-size: calc(12px * var(--fontScale));
      word-break: break-word;
    }

    .chart-card .cb{
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .bigsvg{
      width:100%;
      height:auto;
      aspect-ratio: 1000 / 780;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.05);
      background:rgba(0,0,0,.08);
      display:block;
    }

    .sim-wrap{
      display:flex;
      justify-content:center;
      align-items:center;
      gap:10px;
    }

    .caption{
      font-size: calc(12px * var(--fontScale));
      opacity:.82;
      line-height:1.35;
      border-top:1px solid rgba(255,255,255,.06);
      padding-top:8px;
    }

    .caption-details{ }
    .caption-details > summary{ list-style:none; }
    .caption-details > summary::-webkit-details-marker{ display:none; }
    .caption-toggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      font-size: calc(12px * var(--fontScale));
      opacity:.95;
      cursor:pointer;
      user-select:none;
      color:var(--text);
    }
    .caption-toggle:hover{
      border-color: rgba(254,247,2,.25);
      background:rgba(255,255,255,.04);
      color:#fff;
    }

    .pyr-frame{
      display:grid;
      grid-template-columns: 52px 1fr;
      gap:10px;
      align-items:stretch;
    }
    .pyr-svg{
      width:100%;
      height:auto;
      aspect-ratio: 520 / 720;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.05);
      background:rgba(0,0,0,.08);
      display:block;
    }

    .vslider-shell{
      background:rgba(0,0,0,.10);
      border:1px solid rgba(255,255,255,.06);
      border-radius:14px;
      padding:10px 6px;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      height:100%;
      align-self:stretch;
      position:relative;
    }

    .vslider-shell input[type="range"]{
      -webkit-appearance: none;
      appearance: none;
      width: 240px;
      height: 4px;
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%,-50%) rotate(-90deg);
      transform-origin: center;
      cursor: pointer;
      display:block;
    }

    .ctl{ display:grid; gap:8px; }
    .ctl label{
      font-size: calc(13px * var(--fontScale));
      opacity:.92;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .val{ font-variant-numeric: tabular-nums; opacity:.95; }

    .sys-controls{ display:grid; gap:12px; }
    .sys-grid{ display:grid; gap:12px; }

    #pyrControlsBlock{ display:grid; gap:12px; }

    input[type="range"]{
      width:100%;
      accent-color: var(--primary);
      background: rgba(255,255,255,.12);
      border-radius:999px;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      touch-action: pan-y;
    }
    input[type="range"]::-webkit-slider-runnable-track{ height: 6px; background: transparent; border-radius:999px; }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary);
      border: 1px solid rgba(0,0,0,.35);
      margin-top: -6px;
      box-shadow: 0 2px 10px rgba(0,0,0,.35);
    }
    input[type="range"]::-moz-range-track{ height:6px; background: transparent; border-radius:999px; }
    input[type="range"]::-moz-range-thumb{
      width: 18px; height: 18px; border-radius: 50%;
      background: var(--primary);
      border: 1px solid rgba(0,0,0,.35);
      box-shadow: 0 2px 10px rgba(0,0,0,.35);
    }

    .divider{ height:1px; background:rgba(255,255,255,.06); margin:2px 0; }
    .note{ font-size: calc(11px * var(--fontScale)); opacity:.75; line-height:1.35; }
    .mono{ font-variant-numeric: tabular-nums; font-feature-settings: "tnum" 1, "ss01" 1; }

    .result-pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      font-size: calc(12px * var(--fontScale));
      opacity:.95;
      flex:1 1 auto;
      min-width: 0;
    }
    .result-dot{
      width:9px; height:9px; border-radius:50%;
      background: var(--primary);
      box-shadow:0 0 0 3px rgba(254,247,2,.12);
    }
    .result-dot.bad{ background: var(--retired); box-shadow:0 0 0 3px rgba(255,106,0,.12); }
    .result-dot.ok{ background: var(--workers); box-shadow:0 0 0 3px rgba(54,195,255,.12); }

    .mini-pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 9px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      font-size: calc(12px * var(--fontScale));
      opacity:.95;
      white-space:nowrap;
    }
    .mini-dot{
      width:9px; height:9px; border-radius:999px;
      background: var(--workers);
      box-shadow:0 0 0 3px rgba(54,195,255,.12);
    }
    .mini-dot.bad{ background: var(--retired); box-shadow:0 0 0 3px rgba(255,106,0,.12); }

    .cp-below{
      display:grid;
      gap:10px;
      padding:10px;
      border:1px solid rgba(255,255,255,.06);
      border-radius:12px;
      background:rgba(0,0,0,.08);
    }

    .cp-ratio-hero{
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      justify-content:flex-start;
      gap:10px;
      padding:10px;
      border:1px solid rgba(255,255,255,.06);
      border-radius:12px;
      background:rgba(0,0,0,.08);
    }
    .cp-ratio-hero .left{
      display:flex;
      align-items:center;
      gap:12px;
      min-width:0;
      width:100%;
    }
    .cp-ratio-hero .label{
      font-size: calc(12px * var(--fontScale));
      opacity:.85;
      margin-bottom:4px;
    }
    .cp-ratio-hero .big{
      font-size: calc(22px * var(--fontScale));
      color:#fff;
      font-family:var(--fontTitle);
      letter-spacing:.3px;
      line-height:1.1;
    }

    .cp-ratio-hero .right{
      width:100%;
      min-width:0;
      display:flex;
      align-items:center;
      justify-content:flex-start;
      flex-wrap:wrap;
      gap:8px;
      margin-left: 0;
      overflow:hidden;
    }

    .hero-icon{
      width:46px;
      height:46px;
      display:block;
      filter: invert(1) brightness(2) saturate(0);
      opacity:.98;
      flex:0 0 auto;
    }

    .worker-icon{
      width:28px;
      height:28px;
      display:block;
      filter: invert(1) brightness(2) saturate(0);
      opacity:.92;
      flex:0 0 auto;
    }

    .plus{
      width:28px; height:28px;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#fff;
      font-size: calc(18px * var(--fontScale));
      opacity:.9;
      border:1px solid rgba(255,255,255,.10);
      border-radius:10px;
      background:rgba(255,255,255,.03);
      flex:0 0 auto;
    }

    .cp-kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px 10px;
      align-items:baseline;
      padding:10px;
      border:1px solid rgba(255,255,255,.06);
      border-radius:12px;
      background:rgba(0,0,0,.08);
      font-size: calc(12px * var(--fontScale));
    }
    .cp-kv .k{ opacity:.85; }
    .cp-kv .v{ color:#fff; font-variant-numeric: tabular-nums; }

    #playBtn, #pauseBtn, #resetBtn{
      background: var(--primary) !important;
      color: #111 !important;
      border-color: rgba(0,0,0,.35) !important;
      padding: 10px 12px !important;
    }
    #playBtn:hover, #pauseBtn:hover, #resetBtn:hover{ filter: brightness(0.95); }

    .disabled-block{
      opacity: .55;
      filter: saturate(0.85);
      pointer-events: none;
    }
  </style>
</head>

<body>
<script>
(function(){
  try{
    // Redirección a versión escritorio cuando el viewport es ancho.
    // Por defecto:
    //  - si este archivo se llama "movil_XXXX.html" → redirige a "XXXX.html"
    //  - si no, usa DESKTOP_FILE (ajústalo a tu nombre real).
    if (window.matchMedia && window.matchMedia("(min-width: 901px)").matches) {
      const DESKTOP_FILE = "simulador.html"; // <-- Cambia esto si tu archivo de escritorio tiene otro nombre.
      const currentFile = (location.pathname.split("/").pop() || "");
      const derivedDesktop = currentFile.startsWith("movil_") ? currentFile.replace(/^movil_/, "") : null;
      const target = derivedDesktop || DESKTOP_FILE;

      if (target && currentFile !== target && !location.pathname.endsWith("/" + target) && !location.pathname.endsWith(target)) {
        window.location.replace(target);
      }
    }
  }catch(e){}
})();
</script>

<header>
  <div class="h-title">
    <h1>Simulador</h1>
    <p></p>
  </div>
  <div class="h-meta">
    <div class="pill"><span class="dot"></span><span><a class="back" href="index.html">Volver</a></span></div>
  </div>
</header>

<main>
  <section class="panel" aria-label="Gráficas del simulador">
    <div class="ph">
      <div class="ttl">Simulación</div>
      <div class="sub mono" id="simMeta">Año: 0 | Población: 47.0 M</div>
    </div>

    <div class="oecdbar" aria-label="Carga de parámetros OCDE">
      <div class="oecd-left">
        <div class="oecd-label">OCDE</div>
        <select class="oecd-select" id="oecdCountrySelect" disabled>
          <option>Cargando países…</option>
        </select>
      </div>

      <button class="oecd-btn primary" id="oecdLoadBtn" type="button" disabled title="Carga τ, ρ, C, P y demografía del país seleccionado">
        Cargar país
      </button>

      <button class="oecd-btn" id="oecdClearBtn" type="button" disabled title="Vuelve al estado hipotético anterior (antes de cargar OCDE)">
        Volver a hipotético
      </button>

      <div class="oecd-nav" aria-label="Navegación de países OCDE">
        <button class="oecd-btn" id="oecdPrevBtn" type="button" disabled title="Carga el país anterior en la lista">
          País anterior
        </button>
        <button class="oecd-btn" id="oecdNextBtn" type="button" disabled title="Carga el país siguiente en la lista">
          País siguiente
        </button>
      </div>

      <label class="oecd-toggle" title="Activa/desactiva el uso de demografía OCDE (proyección) y calibración C/P">
        <input type="checkbox" id="oecdModeToggle" disabled />
        <span>Usar datos OCDE</span>
      </label>

      <details class="oecd-details" id="oecdDetails">
        <summary class="oecd-btn" title="Ver explicación del modo OCDE">Explicación modo OCDE</summary>
        <div class="oecd-details-panel">
          En modo OCDE:
          <br>1) τ y ρ se inicializan con valores del dataset (pendiente k=τ/ρ).
          <br>2) La demografía se lee de OECD_demografia.csv (proyección por edades), y sustituye a los sliders de crec. población y envejecimiento.
          <br>3) C(t) se calibra en t0 para cuadrar C_people ajustando participación/u y se proyecta con la demografía.
          <br>4) P(t) usa Opción B: P(t)=α·(65+)(t) con α calibrado en t0 para que P(t0)=P_people (con checks de plausibilidad y fallback a α=1).
        </div>
      </details>

      <div class="oecd-info mono" id="oecdInfo">Cargando datasets OCDE…</div>
    </div>

    <div class="chart-area">
      <div class="charts-row">

        <!-- Chart 1 -->
        <div class="chart-card" aria-label="Evolución temporal (cotizantes vs jubilados)">
          <div class="ch">
            <div class="cttl">Evolución en el tiempo</div>
            <div class="csub mono" id="tReadout">t: 0</div>
          </div>

          <div class="cb">
            <div class="sim-wrap">
              <svg id="timeSvg" class="bigsvg" viewBox="0 0 1000 1050" preserveAspectRatio="xMidYMid meet" aria-label="Gráfica temporal"></svg>
            </div>

            <div class="sys-controls" aria-label="Parámetros del sistema">
              <div class="sys-grid">
                <div class="ctl">
                  <label>
                    <span>ρ (tasa de reemplazo / parámetro del modelo)</span>
                    <span class="val mono" id="rhoVal">0.80</span>
                  </label>
                  <input id="rhoSlider" type="range" min="0.40" max="1.40" step="0.01" value="0.80" />
                </div>

                <div class="ctl">
                  <label>
                    <span>Tipo de cotización (τ)</span>
                    <span class="val mono" id="tauVal">0.29</span>
                  </label>
                  <input id="tauSlider" type="range" min="0.05" max="0.45" step="0.01" value="0.29" />
                </div>

                <div class="ctl">
                  <label>
                    <span>Paro (u): % de edad laboral que NO cotiza</span>
                    <span class="val mono" id="uVal">10%</span>
                  </label>
                  <input id="uSlider" type="range" min="0" max="35" step="1" value="10" />
                </div>

                <div class="ctl">
                  <label>
                    <span>Crec. población anual</span>
                    <span class="val mono" id="popGrowthVal">0.30%</span>
                  </label>
                  <input id="popGrowthSlider" type="range" min="-1.50" max="2.50" step="0.05" value="0.30" />
                </div>

                <div class="ctl">
                  <label>
                    <span>Envejecimiento anual (Δ share pensión / 65+)</span>
                    <span class="val mono" id="agingVal">+0.20 pp</span>
                  </label>
                  <input id="agingSlider" type="range" min="-0.50" max="0.80" step="0.01" value="0.20" />
                </div>

                <div class="ctl">
                  <label>
                    <span>Años a simular</span>
                    <span class="val mono" id="yearsVal">80</span>
                  </label>
                  <input id="yearsSlider" type="range" min="20" max="140" step="5" value="80" />
                </div>
              </div>

              <div style="display:flex; align-items:flex-start; justify-content:space-between; gap:10px; flex-wrap:wrap;">
                <div class="result-pill" id="resultPill">
                  <span class="result-dot" id="resultDot"></span>
                  <span id="resultText">—</span>
                </div>

                <div style="display:grid; gap:8px; flex: 1 1 100%;">
                  <button id="playBtn" type="button" style="cursor:pointer; border-radius:12px; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.03); color:var(--text); flex:1 1 auto;">
                    Reproducir
                  </button>
                  <button id="pauseBtn" type="button" style="cursor:pointer; border-radius:12px; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.03); color:var(--text); flex:1 1 auto;">
                    Pausar
                  </button>
                  <button id="resetBtn" type="button" style="cursor:pointer; border-radius:12px; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.03); color:var(--text); flex:1 1 auto;">
                    Reset
                  </button>
                </div>
              </div>
            </div>

            <details class="caption-details">
              <summary class="caption-toggle" title="Ver explicación de ρ, τ y k">Explicación ρ, τ y k</summary>
              <div class="caption">
                ρ es un parámetro “resumen” de productividad agregada: captura el nivel de tecnología, la eficiencia organizativa y, en general, cuánta producción (base imponible) genera cada trabajador en promedio. Un ρ más alto significa que, con el mismo número de cotizantes, la economía genera más valor y el sistema puede sostener más pensiones sin aumentar tipos; un ρ más bajo implica el caso contrario (misma población activa, menor capacidad de financiación real). Por su parte, τ representa la intensidad contributiva: el porcentaje del output/labor income que se deriva al sistema (vía cotizaciones/tributación afectada). Subir τ aumenta ingresos por cotizante, pero también refleja una mayor carga sobre salarios y empresas; bajar τ alivia la cuña fiscal pero exige, para el mismo nivel de pensiones, más cotizantes o más productividad. Juntas, ambas variables determinan la pendiente de equilibrio k=τ/ρ, es decir, la “regla” que relaciona cuántos pensionistas pueden financiarse de manera sostenible para un nivel dado de cotizantes.
              </div>
            </details>
          </div>
        </div>

        <!-- Chart 2: C–P -->
        <div class="chart-card" aria-label="Gráfica C vs P (equilibrio)">
          <div class="ch cp-head">
            <div class="cp-head-row">
              <div class="cttl">C–P y equilibrio</div>

              <div class="cp-mid mono" aria-label="k y sostenibilidad">
                <span class="mini-pill" title="Pendiente de la línea de equilibrio">
                  <span class="dot" style="width:8px;height:8px;box-shadow:0 0 0 3px rgba(254,247,2,.10)"></span>
                  <span class="mono" id="kReadoutSim">k: —</span>
                </span>
                <span class="mini-pill" id="cpStatusPill" title="Estado de sostenibilidad">
                  <span class="mini-dot" id="cpStatusDot"></span>
                  <span class="mono" id="cpStatusText">—</span>
                </span>
              </div>

              <div class="cp-right mono" id="cpReadoutSim">C: — | P: —</div>
            </div>
          </div>

          <div class="cb">
            <svg id="cpSvg" class="bigsvg" viewBox="0 0 1000 1000" preserveAspectRatio="xMidYMid meet" aria-label="Gráfica C vs P"></svg>

            <div class="cp-below" aria-label="Indicadores C–P">
              <div class="cp-ratio-hero" id="cpRatioHero">
                <div class="left">
                  <img class="hero-icon" id="heroRetiredIcon" src="figuras/noun-person-8100160.svg" alt="Jubilado" />
                  <div>
                    <div class="label">Ratio C/P</div>
                    <div class="big mono" id="heroCP">—</div>
                  </div>
                </div>

                <div class="right" aria-label="Trabajadores que sostienen a 1 jubilado" id="heroWorkersIcons"></div>
              </div>

              <div class="cp-kv" aria-label="Métricas del sistema (t actual)">
                <div class="k">Cotizantes (C)</div>
                <div class="v mono" id="CVal">—</div>

                <div class="k">Pensionistas (P)</div>
                <div class="v mono" id="PVal">—</div>

                <div class="k">Paro (u)</div>
                <div class="v mono" id="uVal2">—</div>

                <div class="k">Ratio P/C</div>
                <div class="v mono" id="PCRatio">—</div>

                <div class="k">Trabajadores por pensionista (C/P)</div>
                <div class="v mono" id="CPRatio2">—</div>

                <div class="k">τ</div>
                <div class="v mono" id="tauVal2">—</div>

                <div class="k">ρ</div>
                <div class="v mono" id="rhoVal2">—</div>

                <div class="k">k = τ/ρ</div>
                <div class="v mono" id="kVal2">—</div>

                <div class="k">Equilibrio a C actual: P* = k·C</div>
                <div class="v mono" id="PStar2">—</div>
              </div>
            </div>

            <div class="caption">
              Punto (C,P) del país en cada t. Línea amarilla: equilibrio <span class="mono">P = k·C</span>.
              En modo OCDE, <span class="mono">P(t)=α·(65+)(t)</span> y <span class="mono">C(t)</span> se proyecta con demografía y parámetros <span class="mono">participación</span>/<span class="mono">u</span>.
            </div>
          </div>
        </div>

        <!-- Pirámide -->
        <div class="chart-card pyr-in-sim" aria-label="Pirámide poblacional y controles">
          <div class="ch">
            <div class="cttl">Pirámide</div>
            <div class="csub mono" id="pyrMeta">Población total: 47.0 M</div>
          </div>

          <div class="cb">
            <div class="pyr-frame">
              <div class="vslider-shell" id="peakShell" title="Pico (quinquenio)">
                <input id="peakSlider" type="range" min="0" max="20" step="1" value="9" />
              </div>

              <svg id="pyrSvg" class="pyr-svg" viewBox="0 0 520 650" preserveAspectRatio="xMidYMid meet" aria-label="Pirámide por quinquenios"></svg>
            </div>

            <div id="pyrControlsBlock">
              <div class="ctl">
                <label>
                  <span>Dispersión del perfil etario (σ)</span>
                  <span class="val mono" id="sigmaVal">18</span>
                </label>
                <input id="sigmaSlider" type="range" min="6" max="40" step="1" value="18" />
              </div>

              <div class="ctl">
                <label>
                  <span>Densidad jóvenes (parte inferior)</span>
                  <span class="val mono" id="densityYoungVal">0.75</span>
                </label>
                <input id="densityYoungSlider" type="range" min="0.35" max="1.25" step="0.01" value="0.75" />
              </div>

              <div class="ctl">
                <label>
                  <span>Densidad mayores (parte superior)</span>
                  <span class="val mono" id="densityOldVal">0.75</span>
                </label>
                <input id="densityOldSlider" type="range" min="0.35" max="1.25" step="0.01" value="0.75" />
              </div>

              <div class="divider"></div>

              <div class="ctl">
                <label>
                  <span>Total población (millones)</span>
                  <span class="val mono" id="popVal">47.0</span>
                </label>
                <input id="popSlider" type="range" min="0.1" max="400" step="0.1" value="47" />
              </div>

              <div class="note" id="pyrNote">
                En modo OCDE, la pirámide se toma de <span class="mono">OECD_demografia.csv</span> para el año calendario correspondiente a <span class="mono">t</span>, y estos controles quedan bloqueados.
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>
  </section>
</main>

<script>
(() => {
  // ==========================================================
  // FUENTES
  // ==========================================================
  const OECD_PENSIONS_JSON = "merged_countries.json";

  // MOD CLAVE: este CSV es el que me pediste usar (proyección por edad/sexo/año)
  // Debe estar en el mismo directorio que este HTML y servirse vía HTTP (GitHub Pages, etc.).
  const OECD_DEMOG_CSV = "OECD_demografia.csv";

  const NAME_TO_ISO3 = {
    "Alemania":"DEU","Australia":"AUS","Austria":"AUT","Bélgica":"BEL","Canadá":"CAN","Chile":"CHL","Colombia":"COL",
    "Corea del Sur":"KOR","Costa Rica":"CRI","Dinamarca":"DNK","Eslovaquia":"SVK","Eslovenia":"SVN","España":"ESP",
    "Estados Unidos":"USA","Estonia":"EST","Finlandia":"FIN","Francia":"FRA","Grecia":"GRC","Hungría":"HUN","Islandia":"ISL",
    "Irlanda":"IRL","Israel":"ISR","Italia":"ITA","Japón":"JPN","Letonia":"LVA","Lituania":"LTU","Luxemburgo":"LUX","México":"MEX",
    "Noruega":"NOR","Nueva Zelanda":"NZL","Países Bajos":"NLD","Polonia":"POL","Portugal":"PRT","Reino Unido":"GBR",
    "República Checa":"CZE","Suecia":"SWE","Suiza":"CHE","Turquía":"TUR"
  };

  // 18 bins OCDE típicos: 0-4..80-84 y 85+
  const PYR_AGE_ORDER_OECD = [
    "Y_LE4","Y5T9","Y10T14","Y15T19","Y20T24","Y25T29","Y30T34","Y35T39","Y40T44","Y45T49",
    "Y50T54","Y55T59","Y60T64","Y65T69","Y70T74","Y75T79","Y80T84","Y_GE85"
  ];

  const AGE_LABELS = [
    "0-4","5-9","10-14","15-19","20-24","25-29","30-34","35-39","40-44","45-49",
    "50-54","55-59","60-64","65-69","70-74","75-79","80-84","85-89","90-94","95-99","100+"
  ];

  // Split 85+ -> 85-89, 90-94, 95-99, 100+ (aprox)
  const SPLIT_85P = [0.56, 0.26, 0.12, 0.06];

  const CSS = (v) => getComputedStyle(document.documentElement).getPropertyValue(v).trim();

  // Contexto de renderizado: qué gráfica está pintándose (para escalas independientes)
  let CHART_CTX_ID = null; // 'timeSvg' | 'cpSvg' | 'pyrSvg'
  const setChartCtx = (id) => { CHART_CTX_ID = id || null; };
  const COLORS = {
    primary: CSS('--primary'),
    text: CSS('--text'),
    grid: CSS('--grid'),
    workers: CSS('--workers'),
    retired: CSS('--retired'),
    minors: CSS('--minors'),
    noncot: CSS('--noncot')
  };

  // ==========================================================
  // PERSISTENCIA (Paso 1 y Paso 2)
  // Lee la pirámide y los parámetros de tiempo guardados en localStorage
  // por piramidePoblacional.html y parametrosTiempo.html
  // ==========================================================
  const PYR_KEY  = "pensionSim_pyramid_v1";
  const TIME_KEY = "pensionSim_time_v1";

  function loadFromStorage(){
    // --- Pirámide ---
    try{
      const raw = localStorage.getItem(PYR_KEY);
      if (raw){
        const o = JSON.parse(raw);
        if (o && typeof o === "object"){
          const pop = Number(o.popTotalM);
          if (isFinite(pop)) state.popTotalM = Math.max(0.1, Math.min(400, pop));

          const peak = Number(o.peakIdx);
          if (isFinite(peak)) state.peakIdx = Math.max(0, Math.min(20, Math.round(peak)));

          const sigma = Number(o.sigma);
          if (isFinite(sigma)) state.sigma = Math.max(6, Math.min(40, sigma));

          const dy = Number(o.densityYoung);
          if (isFinite(dy)) state.densityYoung = Math.max(0.35, Math.min(1.25, dy));

          const do_ = Number(o.densityOld);
          if (isFinite(do_)) state.densityOld = Math.max(0.35, Math.min(1.25, do_));
        }
      }
    }catch(e){}

    // --- Tiempo ---
    try{
      const raw = localStorage.getItem(TIME_KEY);
      if (raw){
        const o = JSON.parse(raw);
        if (o && typeof o === "object"){
          const rho = Number(o.rho);
          if (isFinite(rho)) state.rho = Math.max(0.40, Math.min(1.40, rho));

          const tau = Number(o.tau);
          if (isFinite(tau)) state.tau = Math.max(0.05, Math.min(0.45, tau));

          const u = Number(o.u);
          if (isFinite(u)) state.u = Math.max(0, Math.min(0.35, u));

          const pg = Number(o.popGrowth);
          if (isFinite(pg)) state.popGrowth = Math.max(-0.015, Math.min(0.025, pg));

          const ag = Number(o.agingPP);
          if (isFinite(ag)) state.agingPP = Math.max(-0.005, Math.min(0.008, ag));

          const years = Number(o.years);
          if (isFinite(years)) state.years = Math.max(20, Math.min(140, Math.round(years)));
        }
      }
    }catch(e){}
  }


  const getFontScale = () => parseFloat(CSS('--fontScale')) || 1;
  const getAxisLabelGap = () => {
    // Unidades base del SVG (antes de su()).
    // Valores más pequeños acercan la etiqueta del eje Y al propio eje.
    const varName = (CHART_CTX_ID === "cpSvg") ? "--axisLabelGapCP" : "--axisLabelGapTime";
    const v = parseFloat(CSS(varName));
    return isFinite(v) ? v : 70;
  };
  const getAxisLabelFontScale = () => {
    const v = parseFloat(CSS('--axisLabelFontScale'));
    return isFinite(v) ? v : 1;
  };

  const getChartFontScale = () => {
    const varName =
      (CHART_CTX_ID === "cpSvg")  ? "--chartFontScaleCP"  :
      (CHART_CTX_ID === "pyrSvg") ? "--chartFontScalePyr" :
                                   "--chartFontScaleTime";
    const v = parseFloat(CSS(varName));
    return isFinite(v) ? v : 1;
  };

  const su = (v) => v * getFontScale() * getChartFontScale();


  const WORKER_POOL = [
    "figuras/noun-avatar-5116460.svg",
    "figuras/noun-avatar-5116462.svg",
    "figuras/noun-avatar-5116468.svg",
    "figuras/noun-avatar-5116478.svg",
    "figuras/noun-avatar-5116479.svg",
    "figuras/noun-avatar-5116480.svg",
    "figuras/noun-avatar-5116482.svg",
    "figuras/noun-avatar-5116484.svg",
    "figuras/noun-avatar-5116485.svg",
    "figuras/noun-avatar-5116492.svg",
    "figuras/noun-avatar-5116506.svg",
    "figuras/noun-nun-5116487.svg"
  ];

  // ==========================================================
  // STATE
  // ==========================================================
  const state = {
    // Pirámide (modo hipotético)
    popTotalM: 47.0,
    peakIdx: 9,
    sigma: 18,
    densityYoung: 0.75,
    densityOld: 0.75,

    // Sistema
    rho: 0.80,
    tau: 0.29,
    u: 0.10,
    popGrowth: 0.003,
    agingPP: 0.002,
    years: 80,

    participation: 1.00, // “participación” laboral (0..1), calibrada en OCDE

    t: 0,
    playing: false,
    lastTs: 0,

    workerIconSeq: [],
    timeLayout: null,
    draggingTime: false,

    // ===== OCDE =====
    oecd: {
      ready: false,
      countriesByName: new Map(),
      oecdNames: [],

      // DEMOG: iso3 -> year -> sex(_M/_F/_T) -> age -> value
      demogByIso3: new Map(),
      demogYearsByIso3: new Map(), // iso3 -> sorted numeric years

      selectedName: null,
      mode: false,

      // Calendario
      baseYear: null,      // año calendario de t=0
      maxT: null,          // horizonte máximo disponible (lastYear-baseYear)
      usesDemog: false,    // si hay demografía cargada para el país

      // Calibración Opción B
      pensionerFactor: 1.0,   // α
      pensionerFactorNote: "",

      // Targets desde el bundle de pensiones
      targets: null,    // {C_people,P_people,tauDate,rhoDate,cDate,pDate}

      // Cache para pirámide del año actual
      pyrYear: null,
      pyrM21: null,
      pyrF21: null,
      pyrFromTotal: false
    },

    // backup del estado hipotético
    hypoBackup: null,
  };

  // ==========================================================
  // ELEMENTS
  // ==========================================================
  const els = {
    timeSvg: document.getElementById('timeSvg'),
    tReadout: document.getElementById('tReadout'),
    simMeta: document.getElementById('simMeta'),

    cpSvg: document.getElementById('cpSvg'),
    cpReadoutSim: document.getElementById('cpReadoutSim'),
    kReadoutSim: document.getElementById('kReadoutSim'),
    cpStatusDot: document.getElementById('cpStatusDot'),
    cpStatusText: document.getElementById('cpStatusText'),

    rhoSlider: document.getElementById('rhoSlider'),
    tauSlider: document.getElementById('tauSlider'),
    uSlider: document.getElementById('uSlider'),
    popGrowthSlider: document.getElementById('popGrowthSlider'),
    agingSlider: document.getElementById('agingSlider'),
    yearsSlider: document.getElementById('yearsSlider'),

    rhoVal: document.getElementById('rhoVal'),
    tauVal: document.getElementById('tauVal'),
    uVal: document.getElementById('uVal'),
    popGrowthVal: document.getElementById('popGrowthVal'),
    agingVal: document.getElementById('agingVal'),
    yearsVal: document.getElementById('yearsVal'),

    playBtn: document.getElementById('playBtn'),
    pauseBtn: document.getElementById('pauseBtn'),
    resetBtn: document.getElementById('resetBtn'),

    resultDot: document.getElementById('resultDot'),
    resultText: document.getElementById('resultText'),

    pyrSvg: document.getElementById('pyrSvg'),
    pyrMeta: document.getElementById('pyrMeta'),
    pyrControlsBlock: document.getElementById('pyrControlsBlock'),

    peakSlider: document.getElementById('peakSlider'),
    peakShell: document.getElementById('peakShell'),

    sigmaSlider: document.getElementById('sigmaSlider'),
    sigmaVal: document.getElementById('sigmaVal'),

    densityYoungSlider: document.getElementById('densityYoungSlider'),
    densityYoungVal: document.getElementById('densityYoungVal'),
    densityOldSlider: document.getElementById('densityOldSlider'),
    densityOldVal: document.getElementById('densityOldVal'),

    popSlider: document.getElementById('popSlider'),
    popVal: document.getElementById('popVal'),

    heroCP: document.getElementById('heroCP'),
    heroWorkersIcons: document.getElementById('heroWorkersIcons'),

    CVal: document.getElementById('CVal'),
    PVal: document.getElementById('PVal'),
    uVal2: document.getElementById('uVal2'),
    PCRatio: document.getElementById('PCRatio'),
    CPRatio2: document.getElementById('CPRatio2'),
    tauVal2: document.getElementById('tauVal2'),
    rhoVal2: document.getElementById('rhoVal2'),
    kVal2: document.getElementById('kVal2'),
    PStar2: document.getElementById('PStar2'),

    // OCDE UI
    oecdCountrySelect: document.getElementById('oecdCountrySelect'),
    oecdLoadBtn: document.getElementById('oecdLoadBtn'),
    oecdClearBtn: document.getElementById('oecdClearBtn'),
    oecdModeToggle: document.getElementById('oecdModeToggle'),
    oecdInfo: document.getElementById('oecdInfo'),
    oecdPrevBtn: document.getElementById('oecdPrevBtn'),
    oecdNextBtn: document.getElementById('oecdNextBtn'),
  };

  // ==========================================================
  // HELPERS
  // ==========================================================
  const svgEl = (name, attrs={}) => {
    const el = document.createElementNS("http://www.w3.org/2000/svg", name);
    for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, String(v));
    return el;
  };
  const clearSvg = (svg) => { while (svg.firstChild) svg.removeChild(svg.firstChild); };

  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const toM = (x) => x / 1_000_000;

  const fs = (px) => (px * getFontScale() * getChartFontScale()).toFixed(2);
  const fsTick = (px) => (px * getFontScale() * getChartFontScale()).toFixed(2);
  const fsAxisLabel = (px) => (px * getFontScale() * getAxisLabelFontScale() * getChartFontScale()).toFixed(2);

  const safeNum = (x) => (typeof x === "number" && isFinite(x)) ? x : null;

  function parseCSV(text){
    const rows = [];
    let row = [];
    let cur = "";
    let inQuotes = false;

    for (let i=0;i<text.length;i++){
      const ch = text[i];
      const next = text[i+1];

      if (ch === '"'){
        if (inQuotes && next === '"'){ cur += '"'; i++; }
        else { inQuotes = !inQuotes; }
      } else if (ch === ',' && !inQuotes){
        row.push(cur); cur = "";
      } else if ((ch === '\n' || ch === '\r') && !inQuotes){
        if (ch === '\r' && next === '\n') i++;
        row.push(cur); cur = "";
        if (row.length > 1 || (row.length === 1 && row[0].trim() !== "")) rows.push(row);
        row = [];
      } else {
        cur += ch;
      }
    }
    row.push(cur);
    if (row.length > 1 || (row.length === 1 && row[0].trim() !== "")) rows.push(row);

    if (!rows.length) return { header: [], data: [] };
    return { header: rows[0].map(h => h.trim()), data: rows.slice(1) };
  }

  // ==========================================================
  // BUNDLE PENSIONES (merged_countries.json)
  // ==========================================================
  function pickLatestObservation(observations, predicate){
    const arr = observations.filter(o => predicate(o));
    if (!arr.length) return null;
    arr.sort((a,b) => (b?.period?.date || "").localeCompare(a?.period?.date || ""));
    return arr[0];
  }

  function sumContributionRatesLatest(observations){
    const byMetric = new Map();
    observations.forEach(o => {
      const m = o?.metric;
      if (typeof m !== "string" || !m.startsWith("contribution_rate_")) return;
      const dt = (o?.period?.date || "");
      if (!byMetric.has(m)) byMetric.set(m, o);
      else {
        const cur = byMetric.get(m);
        if ((dt || "").localeCompare(cur?.period?.date || "") > 0) byMetric.set(m, o);
      }
    });

    let sum = 0;
    let maxDate = null;
    let count = 0;

    for (const o of byMetric.values()){
      const v = safeNum(o.value);
      if (v === null) continue;
      sum += v;
      count++;
      const dt = o?.period?.date || null;
      if (dt && (!maxDate || dt.localeCompare(maxDate) > 0)) maxDate = dt;
    }
    if (!count) return { tau: null, date: null };
    return { tau: sum, date: maxDate };
  }

  function resolveCountryMetrics(countryEntry){
    if (!countryEntry) return null;

    // Preferencia: inputs del bundle
    const inputs = countryEntry?.inputs;
    if (inputs && typeof inputs === "object"){
      const C_people = safeNum(inputs.C_people);
      const P_people = safeNum(inputs.P_people);
      const rho = safeNum(inputs.rho);
      const tau = safeNum(inputs.tau);
      const k0 = safeNum(inputs.k);
      const k = (k0 !== null) ? k0 : ((tau !== null && rho !== null && rho > 0) ? (tau / rho) : null);

      const lu = countryEntry?.latest_observations_used || null;
      const cDate = lu?.C?.period?.date || null;
      const pDate = lu?.P?.period?.date || null;
      const rhoDate = lu?.rho?.period?.date || null;

      let tauDate = null;
      if (Array.isArray(lu?.tau_components) && lu.tau_components.length){
        const ds = lu.tau_components
          .map(o => (o?.period?.date || null))
          .filter(d => typeof d === "string" && d);
        ds.sort();
        tauDate = ds.length ? ds[ds.length-1] : null;
      }

      return {
        name: countryEntry.country?.name ?? "—",
        C_people, P_people,
        tau, rho, k,
        dates: { tauDate, rhoDate, cDate, pDate }
      };
    }

    // Fallback: esquema antiguo
    if (!Array.isArray(countryEntry.observations)) return null;
    const obs = countryEntry.observations;

    const pObs = pickLatestObservation(obs, o => o.metric === "pensioners_people");
    const P_people = pObs ? safeNum(pObs.value) : null;
    const pDate = pObs?.period?.date || null;

    const cObs = pickLatestObservation(obs, o =>
      o.metric === "contributors_employed_people" ||
      o.metric === "contributors_affiliates_people" ||
      o.metric === "contributors_affiliated_people"
    );
    const C_people = cObs ? safeNum(cObs.value) : null;
    const cDate = cObs?.period?.date || null;

    const rhoObs = pickLatestObservation(obs, o => o.metric === "replacement_rate_gross_full_career");
    const rho = rhoObs ? safeNum(rhoObs.value) : null;
    const rhoDate = rhoObs?.period?.date || null;

    const tauPack = sumContributionRatesLatest(obs);
    const tau = tauPack.tau;
    const tauDate = tauPack.date;

    const k = (tau !== null && rho !== null && rho > 0) ? (tau / rho) : null;

    return {
      name: countryEntry.country?.name ?? "—",
      C_people, P_people,
      tau, rho, k,
      dates: { tauDate, rhoDate, cDate, pDate }
    };
  }

  async function loadPensionsJSON(){
    const res = await fetch(OECD_PENSIONS_JSON, { cache: "no-store" });
    if (!res.ok) throw new Error(`JSON pensiones: HTTP ${res.status}`);
    const json = await res.json();

    let countries = [];
    if (Array.isArray(json?.countries)) {
      countries = json.countries;
    } else if (json?.countries && typeof json.countries === "object") {
      countries = Object.values(json.countries);
    } else {
      countries = [];
    }

    state.oecd.countriesByName.clear();
    state.oecd.oecdNames = [];

    for (const c of countries){
      const name = c?.country?.name;
      if (!name) continue;
      state.oecd.countriesByName.set(name, c);
      state.oecd.oecdNames.push(name);
    }
    state.oecd.oecdNames.sort((a,b)=>a.localeCompare(b, "es"));
  }

  // ==========================================================
  // DEMOGRAFÍA (OECD_demografia.csv)
  // ==========================================================
  async function loadDemografiaCSV(){
    const res = await fetch(OECD_DEMOG_CSV, { cache: "no-store" });
    if (!res.ok) throw new Error(`CSV demografía: HTTP ${res.status}`);
    const text = await res.text();
    const { header, data } = parseCSV(text);

    const idx = (name) => header.indexOf(name);
    const iRef  = idx("REF_AREA");
    const iSex  = idx("SEX");
    const iAge  = idx("AGE");
    const iYear = idx("TIME_PERIOD");
    const iVal  = idx("OBS_VALUE");

    if ([iRef,iSex,iAge,iYear,iVal].some(i => i < 0)){
      throw new Error("CSV demografía: faltan columnas REF_AREA, SEX, AGE, TIME_PERIOD, OBS_VALUE.");
    }

    state.oecd.demogByIso3.clear();
    state.oecd.demogYearsByIso3.clear();

    for (const r of data){
      const ref = (r[iRef] || "").trim();     // ISO3
      let sex   = (r[iSex] || "").trim();     // M/F/T
      const age = (r[iAge] || "").trim();     // Y_LE4...
      const year = (r[iYear] || "").trim();   // yyyy
      const val = Number((r[iVal] || "").trim());

      if (!ref || !year || !isFinite(val)) continue;

      // Nos quedamos con bins quinquenales + 85+ (para pirámide y cálculos 65+/18-64)
      if (!PYR_AGE_ORDER_OECD.includes(age)) continue;

      if (sex === "M") sex = "_M";
      if (sex === "F") sex = "_F";
      if (sex === "T") sex = "_T";
      if (!["_T","_M","_F"].includes(sex)) continue;

      if (!state.oecd.demogByIso3.has(ref)) state.oecd.demogByIso3.set(ref, new Map());
      const byYear = state.oecd.demogByIso3.get(ref);

      if (!byYear.has(year)) byYear.set(year, new Map());
      const bySex = byYear.get(year);

      if (!bySex.has(sex)) bySex.set(sex, new Map());
      bySex.get(sex).set(age, val);
    }

    // Construye años disponibles por país (rápido de consultar)
    for (const [iso3, byYear] of state.oecd.demogByIso3.entries()){
      const years = [...byYear.keys()]
        .map(y => Number(y))
        .filter(n => isFinite(n))
        .sort((a,b)=>a-b);
      state.oecd.demogYearsByIso3.set(iso3, years);
    }
  }

  function buildPyramid21BinsFromOECDMaps(mMap, fMap, tMap){
    const get = (map, code) => safeNum(map?.get(code));

    const mRaw18 = PYR_AGE_ORDER_OECD.map(code => get(mMap, code));
    const fRaw18 = PYR_AGE_ORDER_OECD.map(code => get(fMap, code));
    const tRaw18 = PYR_AGE_ORDER_OECD.map(code => get(tMap, code));

    const hasMF = !(mRaw18.every(v => v === null) || fRaw18.every(v => v === null));
    const fromTotal = !hasMF;

    const vM = (code) => {
      const i = PYR_AGE_ORDER_OECD.indexOf(code);
      const v = hasMF ? mRaw18[i] : tRaw18[i];
      return (v === null ? 0 : v);
    };
    const vF = (code) => {
      const i = PYR_AGE_ORDER_OECD.indexOf(code);
      const v = hasMF ? fRaw18[i] : tRaw18[i];
      return (v === null ? 0 : v);
    };

    const mVals = new Array(21).fill(0);
    const fVals = new Array(21).fill(0);

    const mapDirect = [
      "Y_LE4","Y5T9","Y10T14","Y15T19","Y20T24","Y25T29","Y30T34","Y35T39","Y40T44","Y45T49",
      "Y50T54","Y55T59","Y60T64","Y65T69","Y70T74","Y75T79","Y80T84"
    ];
    for (let i=0;i<mapDirect.length;i++){
      const code = mapDirect[i];
      if (hasMF){
        mVals[i] = vM(code);
        fVals[i] = vF(code);
      } else {
        const t = vM(code);
        mVals[i] = t/2;
        fVals[i] = t/2;
      }
    }

    const t85m = vM("Y_GE85");
    const t85f = vF("Y_GE85");

    if (hasMF){
      for (let j=0;j<4;j++){
        mVals[17+j] = t85m * SPLIT_85P[j];
        fVals[17+j] = t85f * SPLIT_85P[j];
      }
    } else {
      const t = t85m;
      for (let j=0;j<4;j++){
        mVals[17+j] = (t * SPLIT_85P[j]) / 2;
        fVals[17+j] = (t * SPLIT_85P[j]) / 2;
      }
    }

    const totalVals = mVals.map((v,i)=>v + fVals[i]);
    return { mVals, fVals, totalVals, fromTotal };
  }

  function closestYear(years, target){
    if (!years || !years.length) return null;
    const t = Number(target);
    if (!isFinite(t)) return years[0];
    let lo=0, hi=years.length-1;
    if (t <= years[0]) return years[0];
    if (t >= years[hi]) return years[hi];
    while (hi - lo > 1){
      const mid = (lo + hi) >> 1;
      if (years[mid] === t) return years[mid];
      if (years[mid] < t) lo = mid; else hi = mid;
    }
    // decide nearest
    return (Math.abs(years[lo]-t) <= Math.abs(years[hi]-t)) ? years[lo] : years[hi];
  }

  function getDemogMapsForIsoYear(iso3, year){
    const byYear = state.oecd.demogByIso3.get(iso3) || null;
    if (!byYear) return null;
    const years = state.oecd.demogYearsByIso3.get(iso3) || [];
    const y = closestYear(years, year);
    if (y === null) return null;

    const bySex = byYear.get(String(y)) || null;
    if (!bySex) return null;

    const mMap = bySex.get("_M") || null;
    const fMap = bySex.get("_F") || null;
    const tMap = bySex.get("_T") || null;

    return { year: y, mMap, fMap, tMap };
  }

  function sum18(mapOrNull){
    if (!mapOrNull) return 0;
    let s=0;
    for (const code of PYR_AGE_ORDER_OECD){
      const v = safeNum(mapOrNull.get(code));
      if (v !== null) s += v;
    }
    return s;
  }

  function computeGroupsFrom18Bins(tMap, mMap, fMap){
    // Devuelve grupos en personas (minors <18, working 18-64, retired65plus)
    // Preferimos _T; si no, sumamos _M+_F.
    const getT = (code) => safeNum(tMap?.get(code));
    const getMF = (code) => {
      const vm = safeNum(mMap?.get(code)) ?? 0;
      const vf = safeNum(fMap?.get(code)) ?? 0;
      return vm + vf;
    };

    const hasT = !!tMap;
    const v = (code) => {
      const vt = getT(code);
      if (hasT && vt !== null) return vt;
      return getMF(code);
    };

    // Indices: 0..17
    const b = PYR_AGE_ORDER_OECD.map(code => v(code));

    const minors = (b[0]||0) + (b[1]||0) + (b[2]||0) + 0.60*(b[3]||0);
    const working = 0.40*(b[3]||0) + (b[4]||0)+(b[5]||0)+(b[6]||0)+(b[7]||0)+(b[8]||0)+(b[9]||0)+(b[10]||0)+(b[11]||0)+(b[12]||0);
    const retired65 = (b[13]||0)+(b[14]||0)+(b[15]||0)+(b[16]||0)+(b[17]||0);

    const total = b.reduce((a,x)=>a+(x||0),0) || 0;
    return { minors, working, retired65, total };
  }

  function snapshotHypoState(){
    state.hypoBackup = {
      popTotalM: state.popTotalM,
      peakIdx: state.peakIdx,
      sigma: state.sigma,
      densityYoung: state.densityYoung,
      densityOld: state.densityOld,
      rho: state.rho,
      tau: state.tau,
      u: state.u,
      popGrowth: state.popGrowth,
      agingPP: state.agingPP,
      years: state.years,
      participation: state.participation,
      t: state.t,
    };
  }

  function restoreHypoState(){
    const b = state.hypoBackup;
    if (!b) return;

    state.popTotalM = b.popTotalM;
    state.peakIdx = b.peakIdx;
    state.sigma = b.sigma;
    state.densityYoung = b.densityYoung;
    state.densityOld = b.densityOld;
    state.rho = b.rho;
    state.tau = b.tau;
    state.u = b.u;
    state.popGrowth = b.popGrowth;
    state.agingPP = b.agingPP;
    state.years = b.years;
    state.participation = b.participation;
    state.t = b.t;

    state.oecd.mode = false;
    state.oecd.selectedName = null;
    state.oecd.baseYear = null;
    state.oecd.maxT = null;
    state.oecd.usesDemog = false;
    state.oecd.pensionerFactor = 1.0;
    state.oecd.pensionerFactorNote = "";
    state.oecd.targets = null;
    state.oecd.pyrYear = null;
    state.oecd.pyrM21 = null;
    state.oecd.pyrF21 = null;
    state.oecd.pyrFromTotal = false;

    setOecdModeUI(false);
    syncUI();
    renderPyramid();
    renderTimeChart();
  }

  function setOecdModeUI(enabled){
    state.oecd.mode = !!enabled;

    if (els.oecdModeToggle){
      els.oecdModeToggle.checked = !!enabled;
      els.oecdModeToggle.disabled = !state.oecd.ready;
    }
    if (els.oecdClearBtn){
      els.oecdClearBtn.disabled = !enabled;
    }

    // Bloquea controles de pirámide + población cuando OCDE está ON
    if (els.pyrControlsBlock){
      els.pyrControlsBlock.classList.toggle("disabled-block", !!enabled);
    }
    if (els.peakSlider) els.peakSlider.disabled = !!enabled;
    if (els.sigmaSlider) els.sigmaSlider.disabled = !!enabled;
    if (els.densityYoungSlider) els.densityYoungSlider.disabled = !!enabled;
    if (els.densityOldSlider) els.densityOldSlider.disabled = !!enabled;
    if (els.popSlider) els.popSlider.disabled = !!enabled;

    // MOD CLAVE: si usamos demografía, estos sliders dejan de aplicarse (pero se mantienen visibles)
    const demogOn = !!enabled && !!state.oecd.usesDemog;
    if (els.popGrowthSlider) els.popGrowthSlider.disabled = demogOn;
    if (els.agingSlider) els.agingSlider.disabled = demogOn;
  }

  function clampToSlider(val, slider){
    if (!slider || !isFinite(val)) return { v: val, clamped: false };
    const min = Number(slider.min);
    const max = Number(slider.max);
    const v = clamp(val, min, max);
    return { v, clamped: Math.abs(v - val) > 1e-12 };
  }

  function calibrateLabourParams({ C_target, workingAge, uFixed }){
    // Devuelve {participation,u,note}
    let participation = 1.0;
    let u = state.u;
    let note = "";

    if (!isFinite(C_target) || !isFinite(workingAge) || workingAge <= 1) return { participation, u, note: "sin calibrar" };

    if (uFixed !== null && isFinite(uFixed)){
      u = clamp(uFixed, 0, 0.35);
      participation = C_target / (workingAge * Math.max(1e-9, (1 - u)));

      if (participation > 1){
        participation = 1;
        u = 1 - C_target / (workingAge * Math.max(1e-9, participation));
        u = clamp(u, 0, 0.35);
        note = "u fijo, participación cap=1";
      } else {
        note = "u fijo";
      }
      participation = clamp(participation, 0, 1);
      return { participation, u, note };
    }

    // Intento 1: participation=1 -> u implícito
    u = 1 - (C_target / (workingAge * Math.max(1e-9, participation)));

    // Si u sale negativo, significa que C_target > workingAge (imposible), entonces u=0 y ajusto participation
    if (u < 0){
      u = 0;
      participation = C_target / (workingAge * (1 - u));
      participation = clamp(participation, 0, 1);
      note = "u=0, participación ajustada";
      return { participation, u, note };
    }

    // Si u excede el máximo plausible, lo capeo y ajusto participation
    if (u > 0.35){
      u = 0.35;
      participation = C_target / (workingAge * (1 - u));
      participation = clamp(participation, 0, 1);
      // Recalcula u efectivo tras cap (por coherencia)
      u = 1 - (C_target / (workingAge * Math.max(1e-9, participation)));
      u = clamp(u, 0, 0.35);
      note = "u cap=35%, participación ajustada";
      return { participation, u, note };
    }

    u = clamp(u, 0, 0.35);
    participation = clamp(participation, 0, 1);
    note = "participación=1, u implícito";
    return { participation, u, note };
  }

  function applyOecdCountry(countryName){
    if (!state.oecd.ready) return;

    const entry = state.oecd.countriesByName.get(countryName) || null;
    if (!entry){
      els.oecdInfo.textContent = `No hay entrada de pensiones para "${countryName}".`;
      return;
    }

    const m = resolveCountryMetrics(entry);
    if (!m){
      els.oecdInfo.textContent = `No se pudieron resolver métricas para "${countryName}".`;
      return;
    }

    const iso3 = NAME_TO_ISO3[countryName] || null;
    if (!iso3){
      els.oecdInfo.textContent = `No tengo ISO3 para "${countryName}".`;
      return;
    }

    // Snapshot hipotético si es la primera vez
    if (!state.oecd.mode) snapshotHypoState();

    // τ y ρ desde dataset (clamp a sliders)
    const tauPack = clampToSlider(m.tau ?? NaN, els.tauSlider);
    const rhoPack = clampToSlider(m.rho ?? NaN, els.rhoSlider);

    if (isFinite(tauPack.v)) state.tau = tauPack.v;
    if (isFinite(rhoPack.v)) state.rho = rhoPack.v;

    // DEMOG: baseYear/horizonte y pirámide en t0
    const yearsAvail = state.oecd.demogYearsByIso3.get(iso3) || [];
    const hasDemog = yearsAvail.length > 0;
    state.oecd.usesDemog = hasDemog;

    let baseYear = null;
    let maxT = null;
    let demoNote = "DEMOG:—";

    let groups0 = null;
    let pyr0 = null;

    if (hasDemog){
      baseYear = yearsAvail[0];                // t=0 en el primer año disponible (típico: 2024)
      const lastYear = yearsAvail[yearsAvail.length - 1];
      maxT = lastYear - baseYear;

      const maps0 = getDemogMapsForIsoYear(iso3, baseYear);
      if (maps0){
        groups0 = computeGroupsFrom18Bins(maps0.tMap, maps0.mMap, maps0.fMap);
        const built0 = buildPyramid21BinsFromOECDMaps(maps0.mMap, maps0.fMap, maps0.tMap);
        pyr0 = { year: maps0.year, ...built0 };
      }

      if (groups0 && groups0.total > 0){
        state.popTotalM = clamp(toM(groups0.total), Number(els.popSlider.min||0.1), Number(els.popSlider.max||400));
      }

      demoNote = `DEMOG ${baseYear}→${baseYear+maxT} (t max=${maxT})`;
    }

    state.oecd.baseYear = baseYear;
    state.oecd.maxT = maxT;

    // Years: si hay demog, capea a horizonte; si no, deja como estaba
    if (hasDemog && isFinite(maxT) && maxT >= 0){
      state.years = Math.min(state.years, maxT);
      if (els.yearsSlider){
        // no cambiamos max del slider para no romper UI, pero sincronizamos valor
        els.yearsSlider.value = state.years;
      }
    }

    // Calibración Opción B: α = P_people / (65+)(t0), con checks y fallback
    let alpha = 1.0;
    let alphaNote = "";
    if (hasDemog && groups0 && groups0.retired65 > 0 && m.P_people !== null){
      const raw = m.P_people / groups0.retired65;
      alpha = raw;

      // checks de plausibilidad (ajustables)
      // La idea es evitar outliers por mismatch de definiciones/datos.
      if (!isFinite(alpha) || alpha <= 0){
        alpha = 1.0;
        alphaNote = "α inválido → 1";
      } else if (alpha < 0.50 || alpha > 1.60){
        alpha = 1.0;
        alphaNote = `α outlier (${raw.toFixed(2)}) → 1`;
      } else {
        alphaNote = `α=${alpha.toFixed(2)} (calibrado en ${baseYear})`;
      }
    } else {
      alpha = 1.0;
      alphaNote = "α=1 (sin P_people o sin 65+)";
    }
    state.oecd.pensionerFactor = alpha;
    state.oecd.pensionerFactorNote = alphaNote;

    // Calibración C(t): participation/u en t0 para cuadrar C_people, y luego proyecta
    // Si tu bundle ya trae inputs.u (fracción), lo respetamos como u fijo.
    const inputs = (entry?.inputs && typeof entry.inputs === "object") ? entry.inputs : null;
    const uFixed = (inputs && safeNum(inputs.u) !== null) ? clamp(safeNum(inputs.u), 0, 0.35) : null;

    if (hasDemog && groups0 && groups0.working > 0 && m.C_people !== null){
      const cal = calibrateLabourParams({
        C_target: m.C_people,
        workingAge: groups0.working,
        uFixed: uFixed
      });
      state.participation = cal.participation;
      state.u = cal.u;
    } else {
      // Si no hay demog o no hay C_target, mantenemos parámetros actuales.
      state.participation = clamp(state.participation, 0, 1);
      state.u = clamp(state.u, 0, 0.35);
    }

    // Cache pirámide t0 (se irá actualizando al moverte por t)
    if (pyr0){
      state.oecd.pyrYear = pyr0.year;
      state.oecd.pyrM21 = pyr0.mVals.slice();
      state.oecd.pyrF21 = pyr0.fVals.slice();
      state.oecd.pyrFromTotal = !!pyr0.fromTotal;
    } else {
      state.oecd.pyrYear = null;
      state.oecd.pyrM21 = null;
      state.oecd.pyrF21 = null;
      state.oecd.pyrFromTotal = false;
    }

    state.oecd.selectedName = countryName;
    state.oecd.targets = { C_people: m.C_people, P_people: m.P_people, ...m.dates };

    // Activar modo OCDE si hay demog o al menos τ/ρ
    setOecdModeUI(true);

    // Reset tiempo
    state.playing = false;
    state.t = 0;

    // Mensaje info
    const flags = [];
    if (tauPack.clamped) flags.push("τ clamped");
    if (rhoPack.clamped) flags.push("ρ clamped");

    const tauTxt = (m.tau !== null) ? `τ≈${(m.tau).toFixed(3)}${m.dates.tauDate ? " ("+m.dates.tauDate+")" : ""}` : "τ:—";
    const rhoTxt = (m.rho !== null) ? `ρ≈${(m.rho).toFixed(2)}${m.dates.rhoDate ? " ("+m.dates.rhoDate+")" : ""}` : "ρ:—";
    const cpTxt  = (m.C_people !== null && m.P_people !== null) ? `C=${toM(m.C_people).toFixed(2)}M · P=${toM(m.P_people).toFixed(2)}M` : "C/P:—";

    const partTxt = `participación≈${(state.participation*100).toFixed(0)}% · u≈${(state.u*100).toFixed(0)}%`;
    const alphaTxt = `${state.oecd.pensionerFactorNote}`;

    const flagStr = flags.length ? ` · ${flags.join(", ")}` : "";

    els.oecdInfo.textContent =
      `${countryName} · ${demoNote} · ${tauTxt} · ${rhoTxt} · ${cpTxt} · ${partTxt} · ${alphaTxt}${flagStr}`;

    try{ localStorage.setItem("pensionSim_oecdCountry", countryName); }catch(e){}

    // Repintar
    syncUI();
    renderPyramid();
    renderTimeChart();
  }

  // ==========================================================
  // SIMULADOR
  // ==========================================================
  function kEquilibrium(){
    const rho = Math.max(1e-6, state.rho);
    return state.tau / rho;
  }

  function randWorkerIcon(){
    if (!WORKER_POOL.length) return null;
    const i = Math.floor(Math.random() * WORKER_POOL.length);
    return WORKER_POOL[i];
  }

  function paintRange(input){
    if (!input) return;
    const min = Number(input.min || 0);
    const max = Number(input.max || 100);
    const val = Number(input.value || 0);
    const pct = ((val - min) / Math.max(1e-9, (max - min))) * 100;
    input.style.background = `linear-gradient(to right, ${CSS('--primary')} 0%, ${CSS('--primary')} ${pct}%, rgba(255,255,255,.12) ${pct}%, rgba(255,255,255,.12) 100%)`;
  }

  function getRenderedSvgHeight(svg){
    if (!svg) return 0;
    const rect = svg.getBoundingClientRect();
    let h = rect.height;

    const w = rect.width || svg.clientWidth || 0;
    const vb = svg.viewBox && svg.viewBox.baseVal;

    if (w > 0 && vb && vb.width > 0 && vb.height > 0){
      const expected = w * (vb.height / vb.width);
      if (!isFinite(h) || h <= 1){
        h = expected;
      } else if (expected > 1){
        const ratio = h / expected;
        if (ratio < 0.85 || ratio > 1.15) h = expected;
      }
    }

    if (!isFinite(h) || h <= 1){
      const cs = getComputedStyle(svg);
      const cssH = parseFloat(cs.height);
      if (isFinite(cssH) && cssH > 1) h = cssH;
    }

    return (isFinite(h) && h > 0) ? h : 0;
  }

  function syncSidebarToSvg({ shell, input, svg }){
    if (!shell || !input || !svg) return;
    let targetH = getRenderedSvgHeight(svg);
    if (targetH <= 1) return;

    const wrap = svg && svg.parentElement;
    if (wrap){
      const wh = wrap.getBoundingClientRect().height;
      if (isFinite(wh) && wh > targetH) targetH = wh;
    }

    shell.style.height = `${targetH}px`;

    const shellRect = shell.getBoundingClientRect();
    const cs = getComputedStyle(shell);

    const padY = (parseFloat(cs.paddingTop) || 0) + (parseFloat(cs.paddingBottom) || 0);
    const borderY = (parseFloat(cs.borderTopWidth) || 0) + (parseFloat(cs.borderBottomWidth) || 0);

    const usable = Math.max(120, (shellRect.height || targetH) - padY - borderY);
    input.style.width = `${usable}px`;
    input.style.height = `4px`;

    paintRange(input);
  }

  function syncAllSidebars(){
    syncSidebarToSvg({ shell: els.peakShell, input: els.peakSlider, svg: els.pyrSvg });
  }
  function syncAllSidebarsStable(){
    let n = 0;
    const step = () => {
      syncAllSidebars();
      if (++n < 10) requestAnimationFrame(step);
    };
    requestAnimationFrame(step);
  }

  function setupSidebarObservers(){
    if (!("ResizeObserver" in window)) return;

    const ro = new ResizeObserver(() => {
      syncAllSidebarsStable();
      const cp = parseFloat(els.heroCP.textContent);
      if (isFinite(cp)) renderWorkersIcons(cp);
    });

    ro.observe(els.timeSvg);
    ro.observe(els.pyrSvg);
    if (els.peakShell) ro.observe(els.peakShell);
  }

  // ==========================================================
  // PIRÁMIDE HIPOTÉTICA
  // ==========================================================
  function gaussian(x, mu, sigma){
    const z = (x - mu) / Math.max(1e-6, sigma);
    return Math.exp(-0.5 * z * z);
  }
  function densityPower(d){
    return 0.65 + (d - 0.35) * (2.20 - 0.65) / (1.25 - 0.35);
  }
  function buildSyntheticTotalShares(){
    const n = AGE_LABELS.length;
    const peak = state.peakIdx;
    const sigmaModel = state.sigma / 6.0;

    const pYoung = densityPower(state.densityYoung);
    const pOld   = densityPower(state.densityOld);

    const total = new Array(n).fill(0);

    for (let i=0;i<n;i++){
      let v = gaussian(i, peak, sigmaModel);
      v += 0.22 * gaussian(i, 2.0, sigmaModel * 1.6);

      const tailStart = Math.max(0, peak + 4);
      if (i >= tailStart){
        const t = (i - tailStart);
        v += 0.10 * Math.exp(-t / Math.max(1.5, sigmaModel*1.2));
      }

      const p = (i <= peak) ? pYoung : pOld;
      v = Math.pow(Math.max(0, v), p);

      total[i] = v;
    }

    let s = total.reduce((a,b)=>a+b,0);
    if (s <= 0) s = 1;
    for (let i=0;i<n;i++) total[i] /= s;
    return total;
  }

  // ==========================================================
  // SERIE TEMPORAL
  // ==========================================================
  function buildSeries(){
    // MOD CLAVE: si OCDE modo ON y hay demografía, la serie sale del CSV año a año
    if (state.oecd.mode && state.oecd.usesDemog && state.oecd.selectedName){
      const iso3 = NAME_TO_ISO3[state.oecd.selectedName] || null;
      const baseYear = state.oecd.baseYear;
      const maxT = state.oecd.maxT;

      if (!iso3 || !isFinite(baseYear) || !isFinite(maxT) || maxT < 0){
        // fallback
      } else {
        const T = Math.min(state.years, maxT);
        const series = [];

        for (let t=0; t<=T; t++){
          const year = baseYear + t;
          const maps = getDemogMapsForIsoYear(iso3, year);
          if (!maps){
            // Si falta, reusa último disponible
            const fallbackYear = closestYear(state.oecd.demogYearsByIso3.get(iso3)||[], year);
            const maps2 = getDemogMapsForIsoYear(iso3, fallbackYear);
            if (!maps2) continue;
            const g = computeGroupsFrom18Bins(maps2.tMap, maps2.mMap, maps2.fMap);

            const total = g.total;
            const minors = g.minors;
            const workingAge = g.working;

            const labour = workingAge * clamp(state.participation,0,1);
            const unemployed = labour * clamp(state.u,0,1);
            const cotEff = labour - unemployed;
            const inactive = Math.max(0, workingAge - labour);

            const P65 = g.retired65;
            const retired = clamp(state.oecd.pensionerFactor, 0.01, 5.0) * P65;

            series.push({
              t, year: maps2.year,
              total,
              minors,
              cot: cotEff,
              inactive,
              noncot: unemployed,
              retired
            });
            continue;
          }

          const g = computeGroupsFrom18Bins(maps.tMap, maps.mMap, maps.fMap);

          const total = g.total;
          const minors = g.minors;
          const workingAge = g.working;

          const labour = workingAge * clamp(state.participation,0,1);
          const unemployed = labour * clamp(state.u,0,1);
          const cotEff = labour - unemployed;
          const inactive = Math.max(0, workingAge - labour);

          const P65 = g.retired65;
          const retired = clamp(state.oecd.pensionerFactor, 0.01, 5.0) * P65;

          series.push({
            t, year: maps.year,
            total,
            minors,
            cot: cotEff,
            inactive,
            noncot: unemployed,
            retired
          });
        }

        return series;
      }
    }

    // ===== fallback: modo hipotético (original) =====
    const T = state.years;
    const series = [];
    let total = state.popTotalM * 1_000_000;

    // Shares base desde pirámide sintética
    const shares = buildSyntheticTotalShares();

    const minors0 =
      (shares[0]||0) + (shares[1]||0) + (shares[2]||0) + 0.60*(shares[3]||0);
    let work0 = 0.40*(shares[3]||0);
    for (let i=4;i<=12;i++) work0 += (shares[i]||0);
    let retired0 = 0;
    for (let i=13;i<shares.length;i++) retired0 += (shares[i]||0);

    let s = minors0 + work0 + retired0;
    if (s <= 1e-9) s = 1;

    let sMin = minors0/s, sWork = work0/s, sRet = retired0/s;

    for (let t=0; t<=T; t++){
      const minors = total * sMin;
      const workingAge = total * sWork;
      const retired = total * sRet;

      const labour = workingAge * clamp(state.participation,0,1);
      const unemployed = labour * clamp(state.u,0,1);
      const cotEff = labour - unemployed;
      const inactive = Math.max(0, workingAge - labour);

      series.push({
        t, year: null,
        total,
        minors,
        cot: cotEff,
        inactive,
        noncot: unemployed,
        retired
      });

      total = total * (1 + state.popGrowth);

      const dR = state.agingPP;
      let takeFromWork = Math.min(sWork, dR);
      sWork -= takeFromWork;
      let rem = dR - takeFromWork;
      if (rem > 0){
        let takeFromMin = Math.min(sMin, rem);
        sMin -= takeFromMin;
      }
      sRet = clamp(sRet + dR, 0.02, 0.85);

      const n = sMin + sWork + sRet;
      if (n > 1e-9){
        sMin /= n; sWork /= n; sRet /= n;
      }
    }
    return series;
  }

  function renderTimeLegendHorizontal(svg, y){
    const items = [
      { label: "Menores (<18)", fill: COLORS.minors, op: "0.35" },
      { label: "Cotizantes efectivos", fill: COLORS.workers, op: "0.50" },
      { label: "Desempleados", fill: COLORS.noncot, op: "0.55" },
      { label: "Pensionistas", fill: COLORS.retired, op: "0.50" }
    ];

    const g = svgEl('g', { "opacity":"0.95" });

    const box = su(14);
    const gap = su(10);
    const rowH = su(24);

    const startY = y - ((items.length - 1) * rowH) / 2;

    items.forEach((it, i) => {
      const yy = startY + i * rowH;

      g.appendChild(svgEl('rect', {
        x: 0, y: yy - (box - su(2)),
        width: box, height: box,
        fill: it.fill,
        "fill-opacity": it.op,
        stroke: COLORS.text,
        "stroke-width":"1",
        "stroke-opacity":"0.20",
        rx:"3", ry:"3"
      }));

      const t = svgEl('text', {
        x: box + gap,
        y: yy + 2,
        fill: COLORS.text,
        "font-size": fsTick(22),
        "font-family":"Arial, sans-serif",
        "text-anchor":"start",
        "opacity":"0.92"
      });
      t.textContent = it.label;
      g.appendChild(t);
    });

    svg.appendChild(g);

    try{
      const bb = g.getBBox();
      const tx = (1000 - bb.width) / 2 - bb.x;
      g.setAttribute("transform", `translate(${tx.toFixed(2)} 0)`);
    }catch(e){}
  }

  function viewXFromClientX(svg, clientX){
    const rect = svg.getBoundingClientRect();
    if (!rect || rect.width <= 0) return 0;
    return ((clientX - rect.left) / rect.width) * 1000;
  }

  function setTimeFromClientX(clientX){
    const L = state.timeLayout;
    if (!L) return;

    const x = viewXFromClientX(els.timeSvg, clientX);
    const t = ((x - L.pad.l) / L.innerW) * L.T;
    const tt = clamp(Math.round(t), 0, state.years);
    state.t = tt;
    renderTimeChart();
  }

  function setupTimeScrub(){
    els.timeSvg.style.cursor = "ew-resize";
    els.timeSvg.style.touchAction = "none";

    els.timeSvg.addEventListener("pointerdown", (e) => {
      state.playing = false;
      state.draggingTime = true;
      try{ els.timeSvg.setPointerCapture(e.pointerId); }catch(err){}
      setTimeFromClientX(e.clientX);
    });

    els.timeSvg.addEventListener("pointermove", (e) => {
      if (!state.draggingTime) return;
      setTimeFromClientX(e.clientX);
    });

    const end = () => { state.draggingTime = false; };

    els.timeSvg.addEventListener("pointerup", end);
    els.timeSvg.addEventListener("pointercancel", end);
    els.timeSvg.addEventListener("pointerleave", end);
  }

  // ==========================================================
  // CHART 1
  // ==========================================================
  function renderTimeChart(){
    const svg = els.timeSvg;
    setChartCtx("timeSvg");
    clearSvg(svg);

    const W = 1000, H = 1050;
    const pad = {l: 180, r: 40, t: 40, b: 410};
    const innerW = W - pad.l - pad.r;
    const innerH = H - pad.t - pad.b;

    const data = buildSeries();
    const T = (data.length ? data[data.length-1].t : state.years);

    state.timeLayout = { W, H, pad, innerW, innerH, T };

    const yMax = Math.max(...data.map(d => d.total)) / 1_000_000;
    const yNice = Math.ceil(yMax/5)*5 || 5;

    const xToPx = (x) => pad.l + (x / Math.max(1,T)) * innerW;
    const yToPx = (yM) => pad.t + innerH - (yM / yNice) * innerH;

    const yTicks = 6;
    for (let i=0;i<=yTicks;i++){
      const yv = (yNice * i / yTicks);
      svg.appendChild(svgEl('line',{
        x1: pad.l, y1: yToPx(yv), x2: pad.l+innerW, y2: yToPx(yv),
        stroke: COLORS.grid, "stroke-width":"1", "stroke-opacity":"0.45",
        "stroke-dasharray":"6 6"
      }));
      const t = svgEl('text',{
        x: pad.l - 6, y: yToPx(yv) + 4,
        fill: COLORS.text, "font-size": fsTick(16), "font-family":"Arial, sans-serif",
        "text-anchor":"end", "opacity":"0.90"
      });
      t.textContent = String(Math.round(yv));
      svg.appendChild(t);
    }

    const xTicks = 5;
    for (let i=0;i<=xTicks;i++){
      const xv = Math.round(T * i / xTicks);
      svg.appendChild(svgEl('line',{
        x1: xToPx(xv), y1: pad.t, x2: xToPx(xv), y2: pad.t+innerH,
        stroke: COLORS.grid, "stroke-width":"1", "stroke-opacity":"0.30"
      }));
      const t = svgEl('text',{
        x: xToPx(xv), y: pad.t + innerH + su(26),
        fill: COLORS.text, "font-size": fsTick(16), "font-family":"Arial, sans-serif",
        "text-anchor":"middle", "opacity":"0.90"
      });
      t.textContent = String(xv);
      svg.appendChild(t);
    }

    svg.appendChild(svgEl('line',{
      x1: pad.l, y1: pad.t+innerH, x2: pad.l+innerW, y2: pad.t+innerH,
      stroke: COLORS.text, "stroke-width":"1.2", "stroke-opacity":"0.9"
    }));
    svg.appendChild(svgEl('line',{
      x1: pad.l, y1: pad.t, x2: pad.l, y2: pad.t+innerH,
      stroke: COLORS.text, "stroke-width":"1.2", "stroke-opacity":"0.9"
    }));

    const xAxisLabelY = pad.t + innerH + su(52);

    svg.appendChild(svgEl('text',{
      x: pad.l + innerW/2, y: xAxisLabelY,
      fill: COLORS.text, "font-size": fsAxisLabel(22), "font-family":"Arial, sans-serif",
      "text-anchor":"middle", "opacity":"0.95"
    })).textContent = "Años / turnos";

    const legendY = pad.t + innerH + su(125);
    renderTimeLegendHorizontal(svg, legendY);

    const yLabelX = Math.max(24, pad.l - su(getAxisLabelGap()));
    svg.appendChild(svgEl('text',{
      x: yLabelX, y: pad.t + innerH/2,
      fill: COLORS.text, "font-size": fsAxisLabel(18), "font-family":"Arial, sans-serif",
      "text-anchor":"middle", "opacity":"0.95",
      transform: `rotate(-90 ${yLabelX} ${pad.t + innerH/2})`
    })).textContent = "Personas (millones)";

    const minorsTop = [];
    const cotTop = [];
    const noncotTop = [];
    const totalTop = [];
    const basePts = [];

    data.forEach(d => {
      const x = xToPx(d.t);
      const mM = toM(d.minors);
      const cM = toM(d.cot + (d.inactive || 0));
      const nM = toM(d.noncot);
      const rM = toM(d.retired);

      minorsTop.push([x, yToPx(mM)]);
      cotTop.push([x, yToPx(mM + cM)]);
      noncotTop.push([x, yToPx(mM + cM + nM)]);
      totalTop.push([x, yToPx(mM + cM + nM + rM)]);
      basePts.push([x, yToPx(0)]);
    });

    function polyPath(topPts, bottomPts){
      const pts = topPts.concat(bottomPts.slice().reverse());
      return "M " + pts.map(p => `${p[0].toFixed(2)} ${p[1].toFixed(2)}`).join(" L ") + " Z";
    }

    svg.appendChild(svgEl('path', { d: polyPath(minorsTop, basePts), fill: COLORS.minors, "fill-opacity":"0.35", stroke:"none" }));
    svg.appendChild(svgEl('path', { d: polyPath(cotTop, minorsTop),   fill: COLORS.workers,"fill-opacity":"0.50", stroke:"none" }));
    if (state.u > 1e-9){
      svg.appendChild(svgEl('path', { d: polyPath(noncotTop, cotTop), fill: COLORS.noncot, "fill-opacity":"0.55", stroke:"none" }));
    }
    svg.appendChild(svgEl('path', { d: polyPath(totalTop, noncotTop), fill: COLORS.retired,"fill-opacity":"0.50", stroke:"none" }));

    svg.appendChild(svgEl('path', {
      d: "M " + totalTop.map(p => `${p[0].toFixed(2)} ${p[1].toFixed(2)}`).join(" L "),
      fill: "none",
      stroke: "#FFFFFF",
      "stroke-width":"3",
      "stroke-opacity":"0.95"
    }));

    const tNow = clamp(Math.round(state.t), 0, T);
    const cur = data[Math.min(data.length-1, tNow)];
    const xNow = xToPx(cur.t);

    svg.appendChild(svgEl('line', {
      x1: xNow, y1: pad.t, x2: xNow, y2: pad.t+innerH,
      stroke: COLORS.primary,
      "stroke-width":"2",
      "stroke-opacity":"0.65",
      "stroke-dasharray":"8 6"
    }));

    svg.appendChild(svgEl('circle', {
      cx: xNow, cy: yToPx(toM(cur.total)), r: "0",
      fill: COLORS.primary, "fill-opacity":"0"
    }));

    // tReadout + año calendario si aplica
    const calYear = (cur.year && isFinite(cur.year)) ? ` (${cur.year})` : "";
    els.tReadout.textContent = `t: ${cur.t}${calYear}`;

    const countryTag = (state.oecd.mode && state.oecd.selectedName) ? ` · ${state.oecd.selectedName}` : "";
    const calTag = (cur.year && isFinite(cur.year)) ? ` · Año cal: ${cur.year}` : "";
    els.simMeta.textContent = `Año: ${cur.t} | Población: ${toM(cur.total).toFixed(1)} M${countryTag}${calTag}`;

    updateSystemPill(cur);
    renderCPChartSim(cur, data);

    // MOD: pirámide dinámica por t cuando OCDE+demog
    if (state.oecd.mode && state.oecd.usesDemog) renderPyramid();

    syncAllSidebarsStable();
  }

  function updateSystemPill(cur){
    const C = cur.cot;
    const P = cur.retired;
    const k = kEquilibrium();
    const sustainable = (P <= k * C + 1e-9);

    els.resultDot.classList.remove('ok','bad');
    if (sustainable){
      els.resultDot.classList.add('ok');
      els.resultText.textContent = `Sostenible en t=${cur.t} (P ≤ k·C).`;
    } else {
      els.resultDot.classList.add('bad');
      const Cneeded = (k>0) ? (P / k) : Infinity;
      const missing = (Cneeded===Infinity) ? Infinity : Math.max(0, Cneeded - C);
      els.resultText.textContent = `No cierra en t=${cur.t}: faltan ${toM(missing).toFixed(2)} M cotizantes (a τ y ρ actuales).`;
    }
  }

  // ==========================================================
  // CHART 2 (C–P)
  // ==========================================================
  function niceCeil(x, step){
    if (!isFinite(x) || x <= 0) return step;
    return Math.ceil(x / step) * step;
  }
  function ticksFrom(max, step){
    const out = [];
    const n = Math.round(max / step);
    for (let i=0;i<=n;i++){
      const v = i * step;
      out.push(Math.abs(v) < 1e-12 ? 0 : v);
    }
    if (out[out.length-1] !== max) out.push(max);
    return out;
  }
  function stepForMax(m){
    if (m <= 2)  return 0.5;
    if (m <= 5)  return 1;
    if (m <= 10) return 2;
    if (m <= 25) return 5;
    if (m <= 50) return 10;
    return 20;
  }

  function renderCPChartSim(cur, series){
    const svg = els.cpSvg;
    setChartCtx("cpSvg");
    clearSvg(svg);

    const W = 1000, H = 1000;
    const pad = {l: 170, r: 40, t: 40, b: 210};
    const innerW = W - pad.l - pad.r;
    const innerH = H - pad.t - pad.b;

    const C = toM(cur.cot);
    const P = toM(cur.retired);
    const k = kEquilibrium();

    const CmaxRaw = Math.max(...series.map(d => toM(d.cot)));
    const PmaxRaw = Math.max(...series.map(d => toM(d.retired)));

    const cStep = stepForMax(CmaxRaw);
    const pStep = stepForMax(PmaxRaw);

    const xMax = niceCeil(CmaxRaw * 1.10, cStep);
    const yMax = niceCeil(PmaxRaw * 1.10, pStep);

    const xTicks = ticksFrom(xMax, cStep);
    const yTicks = ticksFrom(yMax, pStep);

    const xToPx = (x) => pad.l + (x / xMax) * innerW;
    const yToPx = (y) => pad.t + innerH - (y / yMax) * innerH;

    yTicks.forEach(v => {
      svg.appendChild(svgEl('line',{
        x1: pad.l, y1: yToPx(v), x2: pad.l+innerW, y2: yToPx(v),
        stroke: COLORS.grid, "stroke-width":"1", "stroke-opacity":"0.45",
        "stroke-dasharray":"6 6"
      }));
      const t = svgEl('text',{
        x: pad.l - 6, y: yToPx(v) + 4,
        fill: COLORS.text, "font-size": fsTick(16),
        "font-family":"Arial, sans-serif",
        "text-anchor":"end", "opacity":"0.90"
      });
      t.textContent = String(v);
      svg.appendChild(t);
    });

    xTicks.forEach(v => {
      svg.appendChild(svgEl('line',{
        x1: xToPx(v), y1: pad.t, x2: xToPx(v), y2: pad.t+innerH,
        stroke: COLORS.grid, "stroke-width":"1", "stroke-opacity":"0.35"
      }));
      const t = svgEl('text',{
        x: xToPx(v), y: pad.t + innerH + su(26),
        fill: COLORS.text, "font-size": fsTick(16),
        "font-family":"Arial, sans-serif",
        "text-anchor":"middle", "opacity":"0.90"
      });
      t.textContent = String(v);
      svg.appendChild(t);
    });

    svg.appendChild(svgEl('line',{
      x1: pad.l, y1: pad.t+innerH, x2: pad.l+innerW, y2: pad.t+innerH,
      stroke: COLORS.text, "stroke-width":"1.2", "stroke-opacity":"0.9"
    }));
    svg.appendChild(svgEl('line',{
      x1: pad.l, y1: pad.t, x2: pad.l, y2: pad.t+innerH,
      stroke: COLORS.text, "stroke-width":"1.2", "stroke-opacity":"0.9"
    }));

    const xAxisLabelY = pad.t + innerH + su(52);
    svg.appendChild(svgEl('text',{
      x: pad.l + innerW/2, y: xAxisLabelY,
      fill: COLORS.text, "font-size": fsAxisLabel(18),
      "font-family":"Arial, sans-serif",
      "text-anchor":"middle", "opacity":"0.95"
    })).textContent = "Cotizantes (millones)";

    const yLabelX = Math.max(24, pad.l - su(getAxisLabelGap()));
    svg.appendChild(svgEl('text',{
      x: yLabelX, y: pad.t + innerH/2,
      fill: COLORS.text, "font-size": fsAxisLabel(18),
      "font-family":"Arial, sans-serif",
      "text-anchor":"middle", "opacity":"0.95",
      transform: `rotate(-90 ${yLabelX} ${pad.t + innerH/2})`
    })).textContent = "Pensionistas (millones)";

    if (isFinite(k) && k > 0){
      const xAtTop = yMax / k;
      let xEnd, yEnd;
      if (xAtTop <= xMax){ xEnd = xAtTop; yEnd = yMax; }
      else { xEnd = xMax; yEnd = k * xMax; }

      svg.appendChild(svgEl('line',{
        x1: xToPx(0), y1: yToPx(0),
        x2: xToPx(xEnd), y2: yToPx(yEnd),
        stroke: COLORS.primary, "stroke-width":"4", "stroke-opacity":"0.95"
      }));
    }

    svg.appendChild(svgEl('line',{
      x1: xToPx(0), y1: yToPx(P),
      x2: xToPx(C), y2: yToPx(P),
      stroke: COLORS.workers, "stroke-width":"2", "stroke-opacity":"0.85",
      "stroke-dasharray":"6 6"
    }));
    svg.appendChild(svgEl('line',{
      x1: xToPx(C), y1: yToPx(0),
      x2: xToPx(C), y2: yToPx(P),
      stroke: COLORS.workers, "stroke-width":"2", "stroke-opacity":"0.85",
      "stroke-dasharray":"6 6"
    }));

    const sustainable = (cur.retired <= k * cur.cot + 1e-9);

    svg.appendChild(svgEl('circle',{
      cx: xToPx(C), cy: yToPx(P), r: 12,
      fill: sustainable ? COLORS.workers : COLORS.retired,
      "fill-opacity":"0.18"
    }));
    svg.appendChild(svgEl('circle',{
      cx: xToPx(C), cy: yToPx(P), r: 7.5,
      fill: COLORS.retired, "fill-opacity":"0.95"
    }));
    svg.appendChild(svgEl('text',{
      x: xToPx(C) + 10, y: yToPx(P) - 10,
      fill: COLORS.retired, "font-size": fs(18),
      "font-family":"Arial, sans-serif", "opacity":"0.95"
    })).textContent = `t=${cur.t}`;

    els.cpReadoutSim.textContent = `C: ${C.toFixed(2)} M | P: ${P.toFixed(2)} M`;
    els.kReadoutSim.textContent = `k: ${k.toFixed(2)}`;
    els.cpStatusDot.classList.toggle("bad", !sustainable);
    els.cpStatusText.textContent = sustainable ? "SOSTENIBLE" : "NO SOSTENIBLE";

    const PC = (C > 0) ? (P / C) : NaN;
    const CP = (P > 0) ? (C / P) : NaN;
    const PStar = k * C;

    els.CVal.textContent = `${C.toFixed(2)} M`;
    els.PVal.textContent = `${P.toFixed(2)} M`;
    els.uVal2.textContent = `${Math.round(state.u * 100)}%`;

    els.PCRatio.textContent = isFinite(PC) ? PC.toFixed(2) : "—";
    els.CPRatio2.textContent = isFinite(CP) ? CP.toFixed(2) : "—";

    els.tauVal2.textContent = state.tau.toFixed(3);
    els.rhoVal2.textContent = state.rho.toFixed(2);
    els.kVal2.textContent = k.toFixed(2);
    els.PStar2.textContent = `${PStar.toFixed(2)} M`;

    els.heroCP.textContent = isFinite(CP) ? CP.toFixed(2) : "—";
    renderWorkersIcons(isFinite(CP) ? CP : NaN);
  }

  function ensureWorkerSeq(cap){
    const target = Math.max(0, cap|0);
    while (state.workerIconSeq.length < target){
      const src = randWorkerIcon();
      if (!src) break;
      state.workerIconSeq.push(src);
    }
  }

  function renderWorkersIcons(cp){
    els.heroWorkersIcons.innerHTML = "";
    if (!isFinite(cp) || cp <= 0) return;

    const N = Math.max(0, Math.round(cp));
    const CAP = 30;
    const show = Math.min(N, CAP);
    const hasPlus = N > CAP;

    ensureWorkerSeq(CAP);

    const avail = els.heroWorkersIcons.getBoundingClientRect().width || 0;

    const maxIcon = 30;
    const minIcon = 14;
    const baseGap = 8;

    let iconSize = maxIcon;
    let gap = baseGap;

    if (avail > 50 && show > 0){
      const tryCompute = (g) => {
        const reserved = (show - 1) * g + (hasPlus ? (g + maxIcon) : 0);
        const s = Math.floor((avail - reserved) / show);
        return s;
      };

      let s = tryCompute(baseGap);
      gap = baseGap;

      if (s < 22){ s = tryCompute(6); gap = 6; }
      if (s < 18){ s = tryCompute(4); gap = 4; }

      iconSize = clamp(s, minIcon, maxIcon);

      if (iconSize <= minIcon && avail < (show * minIcon + (show-1)*gap + (hasPlus ? (gap + minIcon) : 0))){
        let maxShow = Math.max(1, Math.floor((avail - (hasPlus ? (gap + minIcon) : 0) + gap) / (minIcon + gap)));
        maxShow = clamp(maxShow, 1, CAP);
        return renderWorkersIconsWithLayout(N, maxShow, hasPlus, minIcon, gap);
      }
    }

    for (let i=0;i<show;i++){
      const src = state.workerIconSeq[i] || randWorkerIcon();
      if (!src) break;
      const img = document.createElement('img');
      img.className = "worker-icon";
      img.src = src;
      img.alt = "Trabajador";
      img.title = "Trabajador";
      img.style.width = `${iconSize}px`;
      img.style.height = `${iconSize}px`;
      els.heroWorkersIcons.appendChild(img);
    }

    if (hasPlus){
      const plus = document.createElement('div');
      plus.className = "plus";
      plus.textContent = "+";
      plus.style.width = `${iconSize}px`;
      plus.style.height = `${iconSize}px`;
      plus.style.fontSize = `${Math.max(12, iconSize * 0.6)}px`;
      els.heroWorkersIcons.appendChild(plus);
    }

    els.heroWorkersIcons.style.gap = `${gap}px`;
  }

  function renderWorkersIconsWithLayout(N, show, hasPlus, iconSize, gap){
    els.heroWorkersIcons.innerHTML = "";
    ensureWorkerSeq(30);

    for (let i=0;i<show;i++){
      const src = state.workerIconSeq[i] || randWorkerIcon();
      if (!src) break;
      const img = document.createElement('img');
      img.className = "worker-icon";
      img.src = src;
      img.alt = "Trabajador";
      img.title = "Trabajador";
      img.style.width = `${iconSize}px`;
      img.style.height = `${iconSize}px`;
      els.heroWorkersIcons.appendChild(img);
    }

    if (hasPlus){
      const plus = document.createElement('div');
      plus.className = "plus";
      plus.textContent = "+";
      plus.style.width = `${iconSize}px`;
      plus.style.height = `${iconSize}px`;
      plus.style.fontSize = `${Math.max(12, iconSize * 0.6)}px`;
      els.heroWorkersIcons.appendChild(plus);
    }

    els.heroWorkersIcons.style.gap = `${gap}px`;
  }

  // ==========================================================
  // PIRÁMIDE (render) — dinámica si OCDE+demog
  // ==========================================================
  function buildSyntheticSharesMF(){
    const total = buildSyntheticTotalShares();
    const n = total.length;

    const m = new Array(n).fill(0);
    const f = new Array(n).fill(0);
    for (let i=0;i<n;i++){
      const ageFactor = i / (n-1);
      const femaleBias = 0.50 + 0.10 * Math.pow(ageFactor, 1.6);
      const fb = Math.min(0.62, Math.max(0.50, femaleBias));
      f[i] = total[i] * fb;
      m[i] = total[i] * (1 - fb);
    }
    return {m,f};
  }

  function renderPyramid(){
    const svg = els.pyrSvg;
    setChartCtx("pyrSvg");
    clearSvg(svg);

    const W = 520, H = 650;
    const pad = {l: 90, r: 30, t: 52, b: 26};
    const innerW = W - pad.l - pad.r;
    const innerH = H - pad.t - pad.b;
    const cx = pad.l + innerW/2;

    let mBins = null;
    let fBins = null;
    let titleMeta = "";

    if (state.oecd.mode && state.oecd.usesDemog && state.oecd.selectedName){
      const iso3 = NAME_TO_ISO3[state.oecd.selectedName] || null;
      const baseYear = state.oecd.baseYear;
      const maxT = state.oecd.maxT;

      const tNow = clamp(Math.round(state.t), 0, isFinite(maxT)?maxT:0);
      const year = (isFinite(baseYear) ? (baseYear + tNow) : null);

      if (iso3 && year !== null){
        const maps = getDemogMapsForIsoYear(iso3, year);
        if (maps){
          const built = buildPyramid21BinsFromOECDMaps(maps.mMap, maps.fMap, maps.tMap);
          mBins = built.mVals.slice();
          fBins = built.fVals.slice();
          const totalPop = (mBins.reduce((a,b)=>a+b,0) + fBins.reduce((a,b)=>a+b,0)) || 0;
          titleMeta = `${state.oecd.selectedName} · ${maps.year} · ${toM(totalPop).toFixed(1)} M${built.fromTotal ? " (T/2)" : ""}`;

          // cache (opcional)
          state.oecd.pyrYear = maps.year;
          state.oecd.pyrM21 = mBins.slice();
          state.oecd.pyrF21 = fBins.slice();
          state.oecd.pyrFromTotal = !!built.fromTotal;
        }
      }
    }

    if (!mBins || !fBins){
      // fallback hipotético
      const mf = buildSyntheticSharesMF();
      const totalPeople = state.popTotalM * 1_000_000;
      mBins = mf.m.map(s => s * totalPeople);
      fBins = mf.f.map(s => s * totalPeople);
      titleMeta = `Población total: ${state.popTotalM.toFixed(1)} M`;
    }

    const gridLines = 6;
    for (let k=0;k<=gridLines;k++){
      const x = pad.l + (innerW * k/gridLines);
      svg.appendChild(svgEl('line', {
        x1:x, y1:pad.t, x2:x, y2:pad.t+innerH,
        stroke: COLORS.grid, "stroke-width":1, "stroke-opacity":"0.30"
      }));
    }
    svg.appendChild(svgEl('line',{
      x1: cx, y1: pad.t, x2: cx, y2: pad.t+innerH,
      stroke: COLORS.text, "stroke-width":1.2, "stroke-opacity":"0.65"
    }));

    svg.appendChild(svgEl('text',{
      x: cx - 10, y: 50,
      fill: COLORS.workers,
      "font-size": fsTick(16),
      "font-family":"Arial, sans-serif",
      "text-anchor":"end",
      "opacity":"0.92"
    })).textContent = "Hombre";

    svg.appendChild(svgEl('text',{
      x: cx + 10, y: 50,
      fill: COLORS.retired,
      "font-size": fsTick(16),
      "font-family":"Arial, sans-serif",
      "text-anchor":"start",
      "opacity":"0.92"
    })).textContent = "Mujer";

    let maxBin = 0;
    for (let i=0;i<mBins.length;i++) maxBin = Math.max(maxBin, mBins[i]||0, fBins[i]||0);
    if (maxBin <= 0) maxBin = 1;
    const maxPx = (innerW/2) * 0.92;

    const n = AGE_LABELS.length;
    const barH = innerH / n;

    for (let i=0;i<n;i++){
      const y = pad.t + (n - 1 - i) * barH + 1;
      const h = Math.max(1, barH - 2);

      const wL = ((mBins[i]||0) / maxBin) * maxPx;
      const wR = ((fBins[i]||0) / maxBin) * maxPx;

      svg.appendChild(svgEl('rect',{
        x: cx - wL, y, width: wL, height: h,
        fill: COLORS.workers, "fill-opacity":"0.80"
      }));
      svg.appendChild(svgEl('rect',{
        x: cx, y, width: wR, height: h,
        fill: COLORS.retired, "fill-opacity":"0.80"
      }));

      const t = svgEl('text',{
        x: 12, y: y + h*0.72,
        fill: COLORS.text,
        "font-size": fsTick(16),
        "font-family":"Arial, sans-serif",
        "opacity":"0.90"
      });
      t.textContent = AGE_LABELS[i];
      svg.appendChild(t);
    }

    els.pyrMeta.textContent = titleMeta;
    syncAllSidebarsStable();
  }

  // ==========================================================
  // ANIMACIÓN
  // ==========================================================
  function tick(ts){
    if (!state.playing){
      state.lastTs = ts;
      return;
    }
    const dt = Math.min(0.05, (ts - state.lastTs) / 1000);
    state.lastTs = ts;

    state.t = state.t + dt * 12 * 1.0;

    // En OCDE+demog capea a horizonte real si existe
    const maxT = (state.oecd.mode && state.oecd.usesDemog && isFinite(state.oecd.maxT)) ? state.oecd.maxT : state.years;
    if (state.t > maxT) state.t = maxT;

    renderTimeChart();

    if (state.t >= maxT){
      state.playing = false;
    }
  }
  function rafLoop(ts){
    tick(ts);
    requestAnimationFrame(rafLoop);
  }

  // ==========================================================
  // UI SYNC
  // ==========================================================
  function syncUI(){
    els.popSlider.value = state.popTotalM;
    els.popVal.textContent = state.popTotalM.toFixed(1);

    els.peakSlider.value = state.peakIdx;

    els.sigmaSlider.value = state.sigma;
    els.sigmaVal.textContent = String(state.sigma);

    els.densityYoungSlider.value = state.densityYoung;
    els.densityYoungVal.textContent = state.densityYoung.toFixed(2);

    els.densityOldSlider.value = state.densityOld;
    els.densityOldVal.textContent = state.densityOld.toFixed(2);

    els.rhoSlider.value = state.rho;
    els.tauSlider.value = state.tau;
    els.uSlider.value = Math.round(state.u * 100);

    els.popGrowthSlider.value = (state.popGrowth*100).toFixed(2);
    els.agingSlider.value = (state.agingPP*100).toFixed(2);
    els.yearsSlider.value = state.years;

    els.rhoVal.textContent = state.rho.toFixed(2);
    els.tauVal.textContent = state.tau.toFixed(2);
    els.uVal.textContent = Math.round(state.u * 100) + "%";
    els.popGrowthVal.textContent = (state.popGrowth*100).toFixed(2) + "%";
    els.agingVal.textContent = (state.agingPP*100).toFixed(2) + " pp";
    els.yearsVal.textContent = String(state.years);

    [
      els.rhoSlider, els.tauSlider, els.uSlider, els.popGrowthSlider, els.agingSlider, els.yearsSlider,
      els.sigmaSlider, els.densityYoungSlider, els.densityOldSlider, els.popSlider,
      els.peakSlider
    ].forEach(paintRange);

    // Aplica bloqueos según modo
    setOecdModeUI(state.oecd.mode);

    syncAllSidebarsStable();
  }

  // ==========================================================
  // HANDLERS
  // ==========================================================
  els.peakSlider.addEventListener('input', (e) => {
    if (state.oecd.mode) return;
    state.peakIdx = Number(e.target.value);
    paintRange(els.peakSlider);
    renderPyramid();
    renderTimeChart();
  });

  els.sigmaSlider.addEventListener('input', (e) => {
    if (state.oecd.mode) return;
    state.sigma = Number(e.target.value);
    els.sigmaVal.textContent = String(state.sigma);
    paintRange(els.sigmaSlider);
    renderPyramid();
    renderTimeChart();
  });

  els.densityYoungSlider.addEventListener('input', (e) => {
    if (state.oecd.mode) return;
    state.densityYoung = Number(e.target.value);
    els.densityYoungVal.textContent = state.densityYoung.toFixed(2);
    paintRange(els.densityYoungSlider);
    renderPyramid();
    renderTimeChart();
  });

  els.densityOldSlider.addEventListener('input', (e) => {
    if (state.oecd.mode) return;
    state.densityOld = Number(e.target.value);
    els.densityOldVal.textContent = state.densityOld.toFixed(2);
    paintRange(els.densityOldSlider);
    renderPyramid();
    renderTimeChart();
  });

  els.popSlider.addEventListener('input', (e) => {
    if (state.oecd.mode) return; // bloqueado en OCDE profesional
    state.popTotalM = Number(e.target.value);
    els.popVal.textContent = state.popTotalM.toFixed(1);
    paintRange(els.popSlider);
    renderPyramid();
    renderTimeChart();
  });

  els.rhoSlider.addEventListener('input', (e) => {
    state.rho = Number(e.target.value);
    els.rhoVal.textContent = state.rho.toFixed(2);
    paintRange(els.rhoSlider);
    renderTimeChart();
  });

  els.tauSlider.addEventListener('input', (e) => {
    state.tau = Number(e.target.value);
    els.tauVal.textContent = state.tau.toFixed(2);
    paintRange(els.tauSlider);
    renderTimeChart();
  });

  els.uSlider.addEventListener('input', (e) => {
    const v = Number(e.target.value);
    state.u = v / 100.0;
    els.uVal.textContent = v + "%";
    paintRange(els.uSlider);
    renderTimeChart();
  });

  els.popGrowthSlider.addEventListener('input', (e) => {
    if (state.oecd.mode && state.oecd.usesDemog) return; // no aplica en demog
    const vPct = Number(e.target.value);
    state.popGrowth = vPct / 100.0;
    els.popGrowthVal.textContent = vPct.toFixed(2) + "%";
    paintRange(els.popGrowthSlider);
    renderTimeChart();
  });

  els.agingSlider.addEventListener('input', (e) => {
    if (state.oecd.mode && state.oecd.usesDemog) return; // no aplica en demog
    const v = Number(e.target.value);
    state.agingPP = v / 100.0;
    els.agingVal.textContent = v.toFixed(2) + " pp";
    paintRange(els.agingSlider);
    renderTimeChart();
  });

  els.yearsSlider.addEventListener('input', (e) => {
    state.years = Number(e.target.value);

    // Si OCDE+demog, capea al horizonte (sin cambiar el max del slider)
    if (state.oecd.mode && state.oecd.usesDemog && isFinite(state.oecd.maxT)){
      state.years = Math.min(state.years, state.oecd.maxT);
      els.yearsSlider.value = state.years;
    }

    els.yearsVal.textContent = String(state.years);
    state.t = clamp(state.t, 0, state.years);
    paintRange(els.yearsSlider);
    renderTimeChart();
  });

  els.playBtn.addEventListener('click', () => { state.playing = true; });
  els.pauseBtn.addEventListener('click', () => { state.playing = false; });
  els.resetBtn.addEventListener('click', () => {
    state.playing = false;
    state.t = 0;
    renderTimeChart();
  });

  window.addEventListener('resize', () => {
    syncAllSidebarsStable();
    const cp = parseFloat(els.heroCP.textContent);
    if (isFinite(cp)) renderWorkersIcons(cp);
  });

  // ==========================================================
  // OCDE UI
  // ==========================================================
  function renderOecdSelect(){
    const sel = els.oecdCountrySelect;
    if (!sel) return;
    sel.innerHTML = "";
    state.oecd.oecdNames.forEach(name => {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      sel.appendChild(opt);
    });

    const saved = (() => { try{ return localStorage.getItem("pensionSim_oecdCountry"); }catch(e){ return null; } })();
    const def = (saved && state.oecd.countriesByName.has(saved)) ? saved : (state.oecd.countriesByName.has("España") ? "España" : (state.oecd.oecdNames[0] || null));
    if (def){
      sel.value = def;
      state.oecd.selectedName = def;
    }
    sel.disabled = false;

    els.oecdLoadBtn.disabled = !def;
    els.oecdModeToggle.disabled = false;
    els.oecdModeToggle.checked = state.oecd.mode;

    if (els.oecdPrevBtn) els.oecdPrevBtn.disabled = !def;
    if (els.oecdNextBtn) els.oecdNextBtn.disabled = !def;
  }

  function shiftOecdCountry(delta){
    const sel = els.oecdCountrySelect;
    if (!sel || sel.disabled) return;
    const n = sel.options.length;
    if (!n) return;

    let idx = sel.selectedIndex;
    if (idx < 0) idx = 0;
    let next = (idx + delta) % n;
    if (next < 0) next += n;

    sel.selectedIndex = next;
    const name = sel.value || null;

    state.oecd.selectedName = name;
    els.oecdLoadBtn.disabled = !name;

    if (name) applyOecdCountry(name);
  }

  function wireOecdUI(){
    if (els.oecdCountrySelect){
      els.oecdCountrySelect.addEventListener("change", (e) => {
        state.oecd.selectedName = e.target.value || null;
        els.oecdLoadBtn.disabled = !state.oecd.selectedName;
        if (els.oecdPrevBtn) els.oecdPrevBtn.disabled = !state.oecd.selectedName;
        if (els.oecdNextBtn) els.oecdNextBtn.disabled = !state.oecd.selectedName;
      });
    }

    if (els.oecdLoadBtn){
      els.oecdLoadBtn.addEventListener("click", () => {
        const name = els.oecdCountrySelect?.value || state.oecd.selectedName;
        if (name) applyOecdCountry(name);
      });
    }

    if (els.oecdPrevBtn){
      els.oecdPrevBtn.addEventListener("click", () => shiftOecdCountry(-1));
    }
    if (els.oecdNextBtn){
      els.oecdNextBtn.addEventListener("click", () => shiftOecdCountry(+1));
    }

    if (els.oecdClearBtn){
      els.oecdClearBtn.addEventListener("click", () => {
        restoreHypoState();
        els.oecdInfo.textContent = "Modo hipotético restaurado.";
      });
    }

    if (els.oecdModeToggle){
      els.oecdModeToggle.addEventListener("change", (e) => {
        const on = !!e.target.checked;

        if (on && !state.oecd.mode){
          const name = els.oecdCountrySelect?.value || state.oecd.selectedName;
          if (name) applyOecdCountry(name);
          else e.target.checked = false;
          return;
        }
        if (!on){
          restoreHypoState();
          els.oecdInfo.textContent = "Modo hipotético restaurado.";
        }
      });
    }
  }

  async function initOECD(){
    els.oecdInfo.textContent = "Cargando datasets OCDE…";
    try{
      await Promise.all([loadPensionsJSON(), loadDemografiaCSV()]);
      state.oecd.ready = true;

      renderOecdSelect();
      wireOecdUI();

      // Stats
      const isoCount = state.oecd.demogByIso3.size;
      let minY = null, maxY = null;
      for (const ys of state.oecd.demogYearsByIso3.values()){
        if (!ys.length) continue;
        minY = (minY===null) ? ys[0] : Math.min(minY, ys[0]);
        maxY = (maxY===null) ? ys[ys.length-1] : Math.max(maxY, ys[ys.length-1]);
      }

      const msg = `Datasets OK · países(bundles)=${state.oecd.oecdNames.length} · DEMOG(ISO3)=${isoCount} · años=${minY ?? "—"}→${maxY ?? "—"}`;
      els.oecdInfo.textContent = msg;

      els.oecdModeToggle.checked = false;
      setOecdModeUI(false);

    }catch(err){
      state.oecd.ready = false;
      els.oecdInfo.textContent =
        `No se pudieron cargar "${OECD_PENSIONS_JSON}" o "${OECD_DEMOG_CSV}". Revisa que existan y se sirvan desde tu repo.`;
      els.oecdCountrySelect.disabled = true;
      els.oecdLoadBtn.disabled = true;
      els.oecdClearBtn.disabled = true;
      els.oecdModeToggle.disabled = true;
      if (els.oecdPrevBtn) els.oecdPrevBtn.disabled = true;
      if (els.oecdNextBtn) els.oecdNextBtn.disabled = true;
      console.error(err);
    }
  }

  // ==========================================================
  // INIT
  // ==========================================================
  ensureWorkerSeq(30);
  loadFromStorage();
  syncUI();
  renderPyramid();
  renderTimeChart();

  setupSidebarObservers();
  setupTimeScrub();

  window.addEventListener('load', () => {
    syncAllSidebarsStable();
    const cp = parseFloat(els.heroCP.textContent);
    if (isFinite(cp)) renderWorkersIcons(cp);
  });

  requestAnimationFrame(rafLoop);

  initOECD();
})();
</script>

</body>
</html>
